{"version":3,"sources":["webpack:///../node_modules/angular-drag-and-drop-lists/angular-drag-and-drop-lists.js"],"names":[],"mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,qCAAqC,oCAAoC;AACzE;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,uCAAuC,EAAE;;AAEtE;AACA;AACA;AACA;;AAEA;AACA,0CAA0C,aAAa;AACvD;AACA;AACA,gDAAgD,oCAAoC,EAAE;AACtF;;AAEA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,+CAA+C,aAAa;AAC5D,0CAA0C,qCAAqC;AAC/E,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,0CAA0C,EAAE;AACzE,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2CAA2C,aAAa;AACxD,SAAS;;AAET;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,2BAA2B;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC","file":"vendors~analytics~floor-plans~inventory~setup~.._node_modules_angular-drag-and-drop-lists_angular-dr~33cc1538.js?_rev=43bf8f702bea7ae07d85","sourcesContent":["/**\n * angular-drag-and-drop-lists v2.1.0\n *\n * Copyright (c) 2014 Marcel Juenemann marcel@juenemann.cc\n * Copyright (c) 2014-2017 Google Inc.\n * https://github.com/marceljuenemann/angular-drag-and-drop-lists\n *\n * License: MIT\n */\n(function(dndLists) {\n\n  // In standard-compliant browsers we use a custom mime type and also encode the dnd-type in it.\n  // However, IE and Edge only support a limited number of mime types. The workarounds are described\n  // in https://github.com/marceljuenemann/angular-drag-and-drop-lists/wiki/Data-Transfer-Design\n  var MIME_TYPE = 'application/x-dnd';\n  var EDGE_MIME_TYPE = 'application/json';\n  var MSIE_MIME_TYPE = 'Text';\n\n  // All valid HTML5 drop effects, in the order in which we prefer to use them.\n  var ALL_EFFECTS = ['move', 'copy', 'link'];\n\n  /**\n   * Use the dnd-draggable attribute to make your element draggable\n   *\n   * Attributes:\n   * - dnd-draggable      Required attribute. The value has to be an object that represents the data\n   *                      of the element. In case of a drag and drop operation the object will be\n   *                      serialized and unserialized on the receiving end.\n   * - dnd-effect-allowed Use this attribute to limit the operations that can be performed. Valid\n   *                      options are \"move\", \"copy\" and \"link\", as well as \"all\", \"copyMove\",\n   *                      \"copyLink\" and \"linkMove\". The semantics of these operations are up to you\n   *                      and have to be implemented using the callbacks described below. If you\n   *                      allow multiple options, the user can choose between them by using the\n   *                      modifier keys (OS specific). The cursor will be changed accordingly,\n   *                      expect for IE and Edge, where this is not supported.\n   * - dnd-type           Use this attribute if you have different kinds of items in your\n   *                      application and you want to limit which items can be dropped into which\n   *                      lists. Combine with dnd-allowed-types on the dnd-list(s). This attribute\n   *                      must be a lower case string. Upper case characters can be used, but will\n   *                      be converted to lower case automatically.\n   * - dnd-disable-if     You can use this attribute to dynamically disable the draggability of the\n   *                      element. This is useful if you have certain list items that you don't want\n   *                      to be draggable, or if you want to disable drag & drop completely without\n   *                      having two different code branches (e.g. only allow for admins).\n   *\n   * Callbacks:\n   * - dnd-dragstart      Callback that is invoked when the element was dragged. The original\n   *                      dragstart event will be provided in the local event variable.\n   * - dnd-moved          Callback that is invoked when the element was moved. Usually you will\n   *                      remove your element from the original list in this callback, since the\n   *                      directive is not doing that for you automatically. The original dragend\n   *                      event will be provided in the local event variable.\n   * - dnd-copied         Same as dnd-moved, just that it is called when the element was copied\n   *                      instead of moved, so you probably want to implement a different logic.\n   * - dnd-linked         Same as dnd-moved, just that it is called when the element was linked\n   *                      instead of moved, so you probably want to implement a different logic.\n   * - dnd-canceled       Callback that is invoked if the element was dragged, but the operation was\n   *                      canceled and the element was not dropped. The original dragend event will\n   *                      be provided in the local event variable.\n   * - dnd-dragend        Callback that is invoked when the drag operation ended. Available local\n   *                      variables are event and dropEffect.\n   * - dnd-selected       Callback that is invoked when the element was clicked but not dragged.\n   *                      The original click event will be provided in the local event variable.\n   * - dnd-callback       Custom callback that is passed to dropzone callbacks and can be used to\n   *                      communicate between source and target scopes. The dropzone can pass user\n   *                      defined variables to this callback.\n   *\n   * CSS classes:\n   * - dndDragging        This class will be added to the element while the element is being\n   *                      dragged. It will affect both the element you see while dragging and the\n   *                      source element that stays at it's position. Do not try to hide the source\n   *                      element with this class, because that will abort the drag operation.\n   * - dndDraggingSource  This class will be added to the element after the drag operation was\n   *                      started, meaning it only affects the original element that is still at\n   *                      it's source position, and not the \"element\" that the user is dragging with\n   *                      his mouse pointer.\n   */\n  dndLists.directive('dndDraggable', ['$parse', '$timeout', function($parse, $timeout) {\n    return function(scope, element, attr) {\n      // Set the HTML5 draggable attribute on the element.\n      element.attr(\"draggable\", \"true\");\n\n      // If the dnd-disable-if attribute is set, we have to watch that.\n      if (attr.dndDisableIf) {\n        scope.$watch(attr.dndDisableIf, function(disabled) {\n          element.attr(\"draggable\", !disabled);\n        });\n      }\n\n      /**\n       * When the drag operation is started we have to prepare the dataTransfer object,\n       * which is the primary way we communicate with the target element\n       */\n      element.on('dragstart', function(event) {\n        event = event.originalEvent || event;\n\n        // Check whether the element is draggable, since dragstart might be triggered on a child.\n        if (element.attr('draggable') == 'false') return true;\n\n        // Initialize global state.\n        dndState.isDragging = true;\n        dndState.itemType = attr.dndType && scope.$eval(attr.dndType).toLowerCase();\n\n        // Set the allowed drop effects. See below for special IE handling.\n        dndState.dropEffect = \"none\";\n        dndState.effectAllowed = attr.dndEffectAllowed || ALL_EFFECTS[0];\n        event.dataTransfer.effectAllowed = dndState.effectAllowed;\n\n        // Internet Explorer and Microsoft Edge don't support custom mime types, see design doc:\n        // https://github.com/marceljuenemann/angular-drag-and-drop-lists/wiki/Data-Transfer-Design\n        var item = scope.$eval(attr.dndDraggable);\n        var mimeType = MIME_TYPE + (dndState.itemType ? ('-' + dndState.itemType) : '');\n        try {\n          event.dataTransfer.setData(mimeType, angular.toJson(item));\n        } catch (e) {\n          // Setting a custom MIME type did not work, we are probably in IE or Edge.\n          var data = angular.toJson({item: item, type: dndState.itemType});\n          try {\n            event.dataTransfer.setData(EDGE_MIME_TYPE, data);\n          } catch (e) {\n            // We are in Internet Explorer and can only use the Text MIME type. Also note that IE\n            // does not allow changing the cursor in the dragover event, therefore we have to choose\n            // the one we want to display now by setting effectAllowed.\n            var effectsAllowed = filterEffects(ALL_EFFECTS, dndState.effectAllowed);\n            event.dataTransfer.effectAllowed = effectsAllowed[0];\n            event.dataTransfer.setData(MSIE_MIME_TYPE, data);\n          }\n        }\n\n        // Add CSS classes. See documentation above.\n        element.addClass(\"dndDragging\");\n        $timeout(function() { element.addClass(\"dndDraggingSource\"); }, 0);\n\n        // Try setting a proper drag image if triggered on a dnd-handle (won't work in IE).\n        if (event._dndHandle && event.dataTransfer.setDragImage) {\n          event.dataTransfer.setDragImage(element[0], 0, 0);\n        }\n\n        // Invoke dragstart callback and prepare extra callback for dropzone.\n        $parse(attr.dndDragstart)(scope, {event: event});\n        if (attr.dndCallback) {\n          var callback = $parse(attr.dndCallback);\n          dndState.callback = function(params) { return callback(scope, params || {}); };\n        }\n\n        event.stopPropagation();\n      });\n\n      /**\n       * The dragend event is triggered when the element was dropped or when the drag\n       * operation was aborted (e.g. hit escape button). Depending on the executed action\n       * we will invoke the callbacks specified with the dnd-moved or dnd-copied attribute.\n       */\n      element.on('dragend', function(event) {\n        event = event.originalEvent || event;\n\n        // Invoke callbacks. Usually we would use event.dataTransfer.dropEffect to determine\n        // the used effect, but Chrome has not implemented that field correctly. On Windows\n        // it always sets it to 'none', while Chrome on Linux sometimes sets it to something\n        // else when it's supposed to send 'none' (drag operation aborted).\n        scope.$apply(function() {\n          var dropEffect = dndState.dropEffect;\n          var cb = {copy: 'dndCopied', link: 'dndLinked', move: 'dndMoved', none: 'dndCanceled'};\n          $parse(attr[cb[dropEffect]])(scope, {event: event});\n          $parse(attr.dndDragend)(scope, {event: event, dropEffect: dropEffect});\n        });\n\n        // Clean up\n        dndState.isDragging = false;\n        dndState.callback = undefined;\n        element.removeClass(\"dndDragging\");\n        element.removeClass(\"dndDraggingSource\");\n        event.stopPropagation();\n\n        // In IE9 it is possible that the timeout from dragstart triggers after the dragend handler.\n        $timeout(function() { element.removeClass(\"dndDraggingSource\"); }, 0);\n      });\n\n      /**\n       * When the element is clicked we invoke the callback function\n       * specified with the dnd-selected attribute.\n       */\n      element.on('click', function(event) {\n        if (!attr.dndSelected) return;\n\n        event = event.originalEvent || event;\n        scope.$apply(function() {\n          $parse(attr.dndSelected)(scope, {event: event});\n        });\n\n        // Prevent triggering dndSelected in parent elements.\n        event.stopPropagation();\n      });\n\n      /**\n       * Workaround to make element draggable in IE9\n       */\n      element.on('selectstart', function() {\n        if (this.dragDrop) this.dragDrop();\n      });\n    };\n  }]);\n\n  /**\n   * Use the dnd-list attribute to make your list element a dropzone. Usually you will add a single\n   * li element as child with the ng-repeat directive. If you don't do that, we will not be able to\n   * position the dropped element correctly. If you want your list to be sortable, also add the\n   * dnd-draggable directive to your li element(s).\n   *\n   * Attributes:\n   * - dnd-list             Required attribute. The value has to be the array in which the data of\n   *                        the dropped element should be inserted. The value can be blank if used\n   *                        with a custom dnd-drop handler that always returns true.\n   * - dnd-allowed-types    Optional array of allowed item types. When used, only items that had a\n   *                        matching dnd-type attribute will be dropable. Upper case characters will\n   *                        automatically be converted to lower case.\n   * - dnd-effect-allowed   Optional string expression that limits the drop effects that can be\n   *                        performed in the list. See dnd-effect-allowed on dnd-draggable for more\n   *                        details on allowed options. The default value is all.\n   * - dnd-disable-if       Optional boolean expresssion. When it evaluates to true, no dropping\n   *                        into the list is possible. Note that this also disables rearranging\n   *                        items inside the list.\n   * - dnd-horizontal-list  Optional boolean expresssion. When it evaluates to true, the positioning\n   *                        algorithm will use the left and right halfs of the list items instead of\n   *                        the upper and lower halfs.\n   * - dnd-external-sources Optional boolean expression. When it evaluates to true, the list accepts\n   *                        drops from sources outside of the current browser tab. This allows to\n   *                        drag and drop accross different browser tabs. The only major browser\n   *                        that does not support this is currently Microsoft Edge.\n   *\n   * Callbacks:\n   * - dnd-dragover         Optional expression that is invoked when an element is dragged over the\n   *                        list. If the expression is set, but does not return true, the element is\n   *                        not allowed to be dropped. The following variables will be available:\n   *                        - event: The original dragover event sent by the browser.\n   *                        - index: The position in the list at which the element would be dropped.\n   *                        - type: The dnd-type set on the dnd-draggable, or undefined if non was\n   *                          set. Will be null for drops from external sources in IE and Edge,\n   *                          since we don't know the type in those cases.\n   *                        - dropEffect: One of move, copy or link, see dnd-effect-allowed.\n   *                        - external: Whether the element was dragged from an external source.\n   *                        - callback: If dnd-callback was set on the source element, this is a\n   *                          function reference to the callback. The callback can be invoked with\n   *                          custom variables like this: callback({var1: value1, var2: value2}).\n   *                          The callback will be executed on the scope of the source element. If\n   *                          dnd-external-sources was set and external is true, this callback will\n   *                          not be available.\n   * - dnd-drop             Optional expression that is invoked when an element is dropped on the\n   *                        list. The same variables as for dnd-dragover will be available, with the\n   *                        exception that type is always known and therefore never null. There\n   *                        will also be an item variable, which is the transferred object. The\n   *                        return value determines the further handling of the drop:\n   *                        - falsy: The drop will be canceled and the element won't be inserted.\n   *                        - true: Signalises that the drop is allowed, but the dnd-drop\n   *                          callback already took care of inserting the element.\n   *                        - otherwise: All other return values will be treated as the object to\n   *                          insert into the array. In most cases you want to simply return the\n   *                          item parameter, but there are no restrictions on what you can return.\n   * - dnd-inserted         Optional expression that is invoked after a drop if the element was\n   *                        actually inserted into the list. The same local variables as for\n   *                        dnd-drop will be available. Note that for reorderings inside the same\n   *                        list the old element will still be in the list due to the fact that\n   *                        dnd-moved was not called yet.\n   *\n   * CSS classes:\n   * - dndPlaceholder       When an element is dragged over the list, a new placeholder child\n   *                        element will be added. This element is of type li and has the class\n   *                        dndPlaceholder set. Alternatively, you can define your own placeholder\n   *                        by creating a child element with dndPlaceholder class.\n   * - dndDragover          Will be added to the list while an element is dragged over the list.\n   */\n  dndLists.directive('dndList', ['$parse', function($parse) {\n    return function(scope, element, attr) {\n      // While an element is dragged over the list, this placeholder element is inserted\n      // at the location where the element would be inserted after dropping.\n      var placeholder = getPlaceholderElement();\n      placeholder.remove();\n\n      var placeholderNode = placeholder[0];\n      var listNode = element[0];\n      var listSettings = {};\n\n      /**\n       * The dragenter event is fired when a dragged element or text selection enters a valid drop\n       * target. According to the spec, we either need to have a dropzone attribute or listen on\n       * dragenter events and call preventDefault(). It should be noted though that no browser seems\n       * to enforce this behaviour.\n       */\n      element.on('dragenter', function (event) {\n        event = event.originalEvent || event;\n\n        // Calculate list properties, so that we don't have to repeat this on every dragover event.\n        var types = attr.dndAllowedTypes && scope.$eval(attr.dndAllowedTypes);\n        listSettings = {\n          allowedTypes: angular.isArray(types) && types.join('|').toLowerCase().split('|'),\n          disabled: attr.dndDisableIf && scope.$eval(attr.dndDisableIf),\n          externalSources: attr.dndExternalSources && scope.$eval(attr.dndExternalSources),\n          horizontal: attr.dndHorizontalList && scope.$eval(attr.dndHorizontalList)\n        };\n\n        var mimeType = getMimeType(event.dataTransfer.types);\n        if (!mimeType || !isDropAllowed(getItemType(mimeType))) return true;\n        event.preventDefault();\n      });\n\n      /**\n       * The dragover event is triggered \"every few hundred milliseconds\" while an element\n       * is being dragged over our list, or over an child element.\n       */\n      element.on('dragover', function(event) {\n        event = event.originalEvent || event;\n\n        // Check whether the drop is allowed and determine mime type.\n        var mimeType = getMimeType(event.dataTransfer.types);\n        var itemType = getItemType(mimeType);\n        if (!mimeType || !isDropAllowed(itemType)) return true;\n\n        // Make sure the placeholder is shown, which is especially important if the list is empty.\n        if (placeholderNode.parentNode != listNode) {\n          element.append(placeholder);\n        }\n\n        if (event.target != listNode) {\n          // Try to find the node direct directly below the list node.\n          var listItemNode = event.target;\n          while (listItemNode.parentNode != listNode && listItemNode.parentNode) {\n            listItemNode = listItemNode.parentNode;\n          }\n\n          if (listItemNode.parentNode == listNode && listItemNode != placeholderNode) {\n            // If the mouse pointer is in the upper half of the list item element,\n            // we position the placeholder before the list item, otherwise after it.\n            var rect = listItemNode.getBoundingClientRect();\n            if (listSettings.horizontal) {\n              var isFirstHalf = event.clientX < rect.left + rect.width / 2;\n            } else {\n              var isFirstHalf = event.clientY < rect.top + rect.height / 2;\n            }\n            listNode.insertBefore(placeholderNode,\n                isFirstHalf ? listItemNode : listItemNode.nextSibling);\n          }\n        }\n\n        // In IE we set a fake effectAllowed in dragstart to get the correct cursor, we therefore\n        // ignore the effectAllowed passed in dataTransfer. We must also not access dataTransfer for\n        // drops from external sources, as that throws an exception.\n        var ignoreDataTransfer = mimeType == MSIE_MIME_TYPE;\n        var dropEffect = getDropEffect(event, ignoreDataTransfer);\n        if (dropEffect == 'none') return stopDragover();\n\n        // At this point we invoke the callback, which still can disallow the drop.\n        // We can't do this earlier because we want to pass the index of the placeholder.\n        if (attr.dndDragover && !invokeCallback(attr.dndDragover, event, dropEffect, itemType)) {\n          return stopDragover();\n        }\n\n        // Set dropEffect to modify the cursor shown by the browser, unless we're in IE, where this\n        // is not supported. This must be done after preventDefault in Firefox.\n        event.preventDefault();\n        if (!ignoreDataTransfer) {\n          event.dataTransfer.dropEffect = dropEffect;\n        }\n\n        element.addClass(\"dndDragover\");\n        event.stopPropagation();\n        return false;\n      });\n\n      /**\n       * When the element is dropped, we use the position of the placeholder element as the\n       * position where we insert the transferred data. This assumes that the list has exactly\n       * one child element per array element.\n       */\n      element.on('drop', function(event) {\n        event = event.originalEvent || event;\n\n        // Check whether the drop is allowed and determine mime type.\n        var mimeType = getMimeType(event.dataTransfer.types);\n        var itemType = getItemType(mimeType);\n        if (!mimeType || !isDropAllowed(itemType)) return true;\n\n        // The default behavior in Firefox is to interpret the dropped element as URL and\n        // forward to it. We want to prevent that even if our drop is aborted.\n        event.preventDefault();\n\n        // Unserialize the data that was serialized in dragstart.\n        try {\n          var data = JSON.parse(event.dataTransfer.getData(mimeType));\n        } catch(e) {\n          return stopDragover();\n        }\n\n        // Drops with invalid types from external sources might not have been filtered out yet.\n        if (mimeType == MSIE_MIME_TYPE || mimeType == EDGE_MIME_TYPE) {\n          itemType = data.type || undefined;\n          data = data.item;\n          if (!isDropAllowed(itemType)) return stopDragover();\n        }\n\n        // Special handling for internal IE drops, see dragover handler.\n        var ignoreDataTransfer = mimeType == MSIE_MIME_TYPE;\n        var dropEffect = getDropEffect(event, ignoreDataTransfer);\n        if (dropEffect == 'none') return stopDragover();\n\n        // Invoke the callback, which can transform the transferredObject and even abort the drop.\n        var index = getPlaceholderIndex();\n        if (attr.dndDrop) {\n          data = invokeCallback(attr.dndDrop, event, dropEffect, itemType, index, data);\n          if (!data) return stopDragover();\n        }\n\n        // The drop is definitely going to happen now, store the dropEffect.\n        dndState.dropEffect = dropEffect;\n        if (!ignoreDataTransfer) {\n          event.dataTransfer.dropEffect = dropEffect;\n        }\n\n        // Insert the object into the array, unless dnd-drop took care of that (returned true).\n        if (data !== true) {\n          scope.$apply(function() {\n            scope.$eval(attr.dndList).splice(index, 0, data);\n          });\n        }\n        invokeCallback(attr.dndInserted, event, dropEffect, itemType, index, data);\n\n        // Clean up\n        stopDragover();\n        event.stopPropagation();\n        return false;\n      });\n\n      /**\n       * We have to remove the placeholder when the element is no longer dragged over our list. The\n       * problem is that the dragleave event is not only fired when the element leaves our list,\n       * but also when it leaves a child element. Therefore, we determine whether the mouse cursor\n       * is still pointing to an element inside the list or not.\n       */\n      element.on('dragleave', function(event) {\n        event = event.originalEvent || event;\n\n        var newTarget = document.elementFromPoint(event.clientX, event.clientY);\n        if (listNode.contains(newTarget) && !event._dndPhShown) {\n          // Signalize to potential parent lists that a placeholder is already shown.\n          event._dndPhShown = true;\n        } else {\n          stopDragover();\n        }\n      });\n\n      /**\n       * Given the types array from the DataTransfer object, returns the first valid mime type.\n       * A type is valid if it starts with MIME_TYPE, or it equals MSIE_MIME_TYPE or EDGE_MIME_TYPE.\n       */\n      function getMimeType(types) {\n        if (!types) return MSIE_MIME_TYPE; // IE 9 workaround.\n        for (var i = 0; i < types.length; i++) {\n          if (types[i] == MSIE_MIME_TYPE || types[i] == EDGE_MIME_TYPE ||\n              types[i].substr(0, MIME_TYPE.length) == MIME_TYPE) {\n            return types[i];\n          }\n        }\n        return null;\n      }\n\n      /**\n       * Determines the type of the item from the dndState, or from the mime type for items from\n       * external sources. Returns undefined if no item type was set and null if the item type could\n       * not be determined.\n       */\n      function getItemType(mimeType) {\n        if (dndState.isDragging) return dndState.itemType || undefined;\n        if (mimeType == MSIE_MIME_TYPE || mimeType == EDGE_MIME_TYPE) return null;\n        return (mimeType && mimeType.substr(MIME_TYPE.length + 1)) || undefined;\n      }\n\n      /**\n       * Checks various conditions that must be fulfilled for a drop to be allowed, including the\n       * dnd-allowed-types attribute. If the item Type is unknown (null), the drop will be allowed.\n       */\n      function isDropAllowed(itemType) {\n        if (listSettings.disabled) return false;\n        if (!listSettings.externalSources && !dndState.isDragging) return false;\n        if (!listSettings.allowedTypes || itemType === null) return true;\n        return itemType && listSettings.allowedTypes.indexOf(itemType) != -1;\n      }\n\n      /**\n       * Determines which drop effect to use for the given event. In Internet Explorer we have to\n       * ignore the effectAllowed field on dataTransfer, since we set a fake value in dragstart.\n       * In those cases we rely on dndState to filter effects. Read the design doc for more details:\n       * https://github.com/marceljuenemann/angular-drag-and-drop-lists/wiki/Data-Transfer-Design\n       */\n      function getDropEffect(event, ignoreDataTransfer) {\n        var effects = ALL_EFFECTS;\n        if (!ignoreDataTransfer) {\n          effects = filterEffects(effects, event.dataTransfer.effectAllowed);\n        }\n        if (dndState.isDragging) {\n          effects = filterEffects(effects, dndState.effectAllowed);\n        }\n        if (attr.dndEffectAllowed) {\n          effects = filterEffects(effects, attr.dndEffectAllowed);\n        }\n        // MacOS automatically filters dataTransfer.effectAllowed depending on the modifier keys,\n        // therefore the following modifier keys will only affect other operating systems.\n        if (!effects.length) {\n          return 'none';\n        } else if (event.ctrlKey && effects.indexOf('copy') != -1) {\n          return 'copy';\n        } else if (event.altKey && effects.indexOf('link') != -1) {\n          return 'link';\n        } else {\n          return effects[0];\n        }\n      }\n\n      /**\n       * Small helper function that cleans up if we aborted a drop.\n       */\n      function stopDragover() {\n        placeholder.remove();\n        element.removeClass(\"dndDragover\");\n        return true;\n      }\n\n      /**\n       * Invokes a callback with some interesting parameters and returns the callbacks return value.\n       */\n      function invokeCallback(expression, event, dropEffect, itemType, index, item) {\n        return $parse(expression)(scope, {\n          callback: dndState.callback,\n          dropEffect: dropEffect,\n          event: event,\n          external: !dndState.isDragging,\n          index: index !== undefined ? index : getPlaceholderIndex(),\n          item: item || undefined,\n          type: itemType\n        });\n      }\n\n      /**\n       * We use the position of the placeholder node to determine at which position of the array the\n       * object needs to be inserted\n       */\n      function getPlaceholderIndex() {\n        return Array.prototype.indexOf.call(listNode.children, placeholderNode);\n      }\n\n      /**\n       * Tries to find a child element that has the dndPlaceholder class set. If none was found, a\n       * new li element is created.\n       */\n      function getPlaceholderElement() {\n        var placeholder;\n        angular.forEach(element.children(), function(childNode) {\n          var child = angular.element(childNode);\n          if (child.hasClass('dndPlaceholder')) {\n            placeholder = child;\n          }\n        });\n        return placeholder || angular.element(\"<li class='dndPlaceholder'></li>\");\n      }\n    };\n  }]);\n\n  /**\n   * Use the dnd-nodrag attribute inside of dnd-draggable elements to prevent them from starting\n   * drag operations. This is especially useful if you want to use input elements inside of\n   * dnd-draggable elements or create specific handle elements. Note: This directive does not work\n   * in Internet Explorer 9.\n   */\n  dndLists.directive('dndNodrag', function() {\n    return function(scope, element, attr) {\n      // Set as draggable so that we can cancel the events explicitly\n      element.attr(\"draggable\", \"true\");\n\n      /**\n       * Since the element is draggable, the browser's default operation is to drag it on dragstart.\n       * We will prevent that and also stop the event from bubbling up.\n       */\n      element.on('dragstart', function(event) {\n        event = event.originalEvent || event;\n\n        if (!event._dndHandle) {\n          // If a child element already reacted to dragstart and set a dataTransfer object, we will\n          // allow that. For example, this is the case for user selections inside of input elements.\n          if (!(event.dataTransfer.types && event.dataTransfer.types.length)) {\n            event.preventDefault();\n          }\n          event.stopPropagation();\n        }\n      });\n\n      /**\n       * Stop propagation of dragend events, otherwise dnd-moved might be triggered and the element\n       * would be removed.\n       */\n      element.on('dragend', function(event) {\n        event = event.originalEvent || event;\n        if (!event._dndHandle) {\n          event.stopPropagation();\n        }\n      });\n    };\n  });\n\n  /**\n   * Use the dnd-handle directive within a dnd-nodrag element in order to allow dragging with that\n   * element after all. Therefore, by combining dnd-nodrag and dnd-handle you can allow\n   * dnd-draggable elements to only be dragged via specific \"handle\" elements. Note that Internet\n   * Explorer will show the handle element as drag image instead of the dnd-draggable element. You\n   * can work around this by styling the handle element differently when it is being dragged. Use\n   * the CSS selector .dndDragging:not(.dndDraggingSource) [dnd-handle] for that.\n   */\n  dndLists.directive('dndHandle', function() {\n    return function(scope, element, attr) {\n      element.attr(\"draggable\", \"true\");\n\n      element.on('dragstart dragend', function(event) {\n        event = event.originalEvent || event;\n        event._dndHandle = true;\n      });\n    };\n  });\n\n  /**\n   * Filters an array of drop effects using a HTML5 effectAllowed string.\n   */\n  function filterEffects(effects, effectAllowed) {\n    if (effectAllowed == 'all') return effects;\n    return effects.filter(function(effect) {\n      return effectAllowed.toLowerCase().indexOf(effect) != -1;\n    });\n  }\n\n  /**\n   * For some features we need to maintain global state. This is done here, with these fields:\n   * - callback: A callback function set at dragstart that is passed to internal dropzone handlers.\n   * - dropEffect: Set in dragstart to \"none\" and to the actual value in the drop handler. We don't\n   *   rely on the dropEffect passed by the browser, since there are various bugs in Chrome and\n   *   Safari, and Internet Explorer defaults to copy if effectAllowed is copyMove.\n   * - effectAllowed: Set in dragstart based on dnd-effect-allowed. This is needed for IE because\n   *   setting effectAllowed on dataTransfer might result in an undesired cursor.\n   * - isDragging: True between dragstart and dragend. Falsy for drops from external sources.\n   * - itemType: The item type of the dragged element set via dnd-type. This is needed because IE\n   *   and Edge don't support custom mime types that we can use to transfer this information.\n   */\n  var dndState = {};\n\n})(angular.module('dndLists', []));\n"],"sourceRoot":""}