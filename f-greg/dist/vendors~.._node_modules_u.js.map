{"version":3,"sources":["webpack:///../node_modules/util-deprecate/browser.js","webpack:///../node_modules/util/node_modules/inherits/inherits_browser.js","webpack:///../node_modules/util/support/isBufferBrowser.js","webpack:///../node_modules/util/util.js","webpack:///../node_modules/webpack/buildin/amd-options.js","webpack:///../node_modules/webpack/buildin/global.js","webpack:///../node_modules/webpack/buildin/harmony-module.js","webpack:///../node_modules/webpack/buildin/module.js","webpack:///../node_modules/websocket-nats/index.js","webpack:///../node_modules/websocket-nats/lib/nats.js","webpack:///../node_modules/websocket-nats/lib/net.js","webpack:///../node_modules/websocket-nats/lib/tls.js"],"names":[],"mappings":";;;;;;;;;;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,aAAa,SAAS;AACtB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,uBAAuB,SAAS;AAChC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4CAA4C,KAAK;;AAEjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;;AAGA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA,WAAW;AACX;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,mBAAO,CAAC,2EAAoB;;AAE/C;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,WAAW,SAAS;AACpB;AACA,mBAAmB,mBAAO,CAAC,gFAAU;;AAErC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kCAAkC;AAC7D,2BAA2B,mDAAmD;AAC9E;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9rBA;AACA;;;;;;;;;;;;;ACDA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;;;;;;;;;;ACrBA,iBAAiB,mBAAO,CAAC,8DAAY;;;;;;;;;;;;;ACArC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACa;;AAEb;AACA;AACA;;AAEA,aAAa,mBAAO,CAAC,sDAAK;AAC1B,aAAa,mBAAO,CAAC,sDAAK;AAC1B,aAAa,mBAAO,CAAC,uCAAK;AAC1B,aAAa,mBAAO,CAAC,0CAAM;AAC3B,aAAa,mBAAO,CAAC,gDAAQ;AAC7B,aAAa,mBAAO,CAAC,2CAAM;;AAE3B;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,iBAAiB,yBAAyB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,6CAA6C,QAAQ;;AAErD;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,iBAAiB,MAAM,EAAE;AACzB,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA,oCAAoC,oBAAoB,EAAE;AAC1D;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB;AACA;;AAEA;AACA,4BAA4B,QAAQ;;AAEpC;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA,qBAAqB,QAAQ;AAC7B;AACA,uCAAuC,eAAe,EAAE;AACxD;;AAEA;AACA;AACA;AACA,0DAA0D,MAAM;AAChE;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,oBAAoB,EAAE;AAC/C;;;;;;;;;;;;;;ACtqCA,8CAAa;;AAEb,WAAW,mBAAO,CAAC,0CAAM;AACzB,mBAAmB,mBAAO,CAAC,gDAAQ;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;;;;;;;;;;;;AC/DA;AACA;AACA","file":"vendors~.._node_modules_u.js?_rev=ab00953d30adcddaebfd","sourcesContent":["\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!global.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = global.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n","module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\n  function getOwnPropertyDescriptors(obj) {\n    var keys = Object.keys(obj);\n    var descriptors = {};\n    for (var i = 0; i < keys.length; i++) {\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n    }\n    return descriptors;\n  };\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  if (typeof process !== 'undefined' && process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Allow for deprecating things in the process of starting up.\n  if (typeof process === 'undefined') {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\n\nexports.promisify = function promisify(original) {\n  if (typeof original !== 'function')\n    throw new TypeError('The \"original\" argument must be of type Function');\n\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n    }\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n    return fn;\n  }\n\n  function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function (resolve, reject) {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n    args.push(function (err, value) {\n      if (err) {\n        promiseReject(err);\n      } else {\n        promiseResolve(value);\n      }\n    });\n\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n\n    return promise;\n  }\n\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n\n  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return Object.defineProperties(\n    fn,\n    getOwnPropertyDescriptors(original)\n  );\n}\n\nexports.promisify.custom = kCustomPromisifiedSymbol\n\nfunction callbackifyOnRejected(reason, cb) {\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\n  // Because `null` is a special error value in callbacks which means \"no error\n  // occurred\", we error-wrap so the callback consumer can distinguish between\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\n  if (!reason) {\n    var newReason = new Error('Promise was rejected with a falsy value');\n    newReason.reason = reason;\n    reason = newReason;\n  }\n  return cb(reason);\n}\n\nfunction callbackify(original) {\n  if (typeof original !== 'function') {\n    throw new TypeError('The \"original\" argument must be of type Function');\n  }\n\n  // We DO NOT return the promise as it gives the user a false sense that\n  // the promise is actually somehow related to the callback's execution\n  // and that the callback throwing will reject the promise.\n  function callbackified() {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    var maybeCb = args.pop();\n    if (typeof maybeCb !== 'function') {\n      throw new TypeError('The last argument must be of type Function');\n    }\n    var self = this;\n    var cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    // In true node style we process the callback on `nextTick` with all the\n    // implications (stack, `uncaughtException`, `async_hooks`)\n    original.apply(this, args)\n      .then(function(ret) { process.nextTick(cb, null, ret) },\n            function(rej) { process.nextTick(callbackifyOnRejected, rej, cb) });\n  }\n\n  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n  Object.defineProperties(callbackified,\n                          getOwnPropertyDescriptors(original));\n  return callbackified;\n}\nexports.callbackify = callbackify;\n","/* globals __webpack_amd_options__ */\nmodule.exports = __webpack_amd_options__;\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","module.exports = function(originalModule) {\n\tif (!originalModule.webpackPolyfill) {\n\t\tvar module = Object.create(originalModule);\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"exports\", {\n\t\t\tenumerable: true\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","module.exports = require('./lib/nats');\n","/*!\n * Nats\n * Copyright(c) 2012-2016 Apcera Inc. All rights reserved.\n * Copyright(c) 2011-2014 Derek Collison (derek.collison@gmail.com)\n * MIT Licensed\n */\n\n/* jslint node: true */\n'use strict';\n\n/**\n * Module Dependencies\n */\n\nvar net    = require('net'),\n    tls    = require('tls'),\n    url    = require('url'),\n    util   = require('util'),\n    events = require('events'),\n    nuid   = require('nuid');\n\n/**\n * Constants\n */\n\nvar VERSION = '0.6.8',\n\n    DEFAULT_PORT = 4222,\n    DEFAULT_PRE  = 'nats://localhost:',\n    DEFAULT_URI  =  DEFAULT_PRE + DEFAULT_PORT,\n\n    MAX_CONTROL_LINE_SIZE = 512,\n\n    // Parser state\n    AWAITING_CONTROL = 0,\n    AWAITING_MSG_PAYLOAD = 1,\n\n    // Reconnect Parameters, 2 sec wait, 10 tries\n    DEFAULT_RECONNECT_TIME_WAIT = 2*1000,\n    DEFAULT_MAX_RECONNECT_ATTEMPTS = 10,\n\n    // Protocol\n    //CONTROL_LINE = /^(.*)\\r\\n/, // TODO: remove / never used\n\n    MSG   = /^MSG\\s+([^\\s\\r\\n]+)\\s+([^\\s\\r\\n]+)\\s+(([^\\s\\r\\n]+)[^\\S\\r\\n]+)?(\\d+)\\r\\n/i,\n    OK    = /^\\+OK\\s*\\r\\n/i,\n    ERR   = /^-ERR\\s+('.+')?\\r\\n/i,\n    PING  = /^PING\\r\\n/i,\n    PONG  = /^PONG\\r\\n/i,\n    INFO  = /^INFO\\s+([^\\r\\n]+)\\r\\n/i,\n    SUBRE = /^SUB\\s+([^\\r\\n]+)\\r\\n/i,\n\n    CR_LF = '\\r\\n',\n    CR_LF_LEN = CR_LF.length,\n    EMPTY = '',\n    SPC = ' ',\n\n    // Protocol\n    //PUB     = 'PUB', // TODO: remove / never used\n    SUB     = 'SUB',\n    UNSUB   = 'UNSUB',\n    CONNECT = 'CONNECT',\n\n    // Responses\n    PING_REQUEST  = 'PING' + CR_LF,\n    PONG_RESPONSE = 'PONG' + CR_LF,\n\n    // Errors\n    BAD_SUBJECT = 'Subject must be supplied',\n    BAD_MSG = 'Message can\\'t be a function',\n    BAD_REPLY = 'Reply can\\'t be a function',\n    CONN_CLOSED = 'Connection closed',\n    BAD_JSON_MSG = 'Message should be a JSON object',\n    BAD_AUTHENTICATION = 'User and Token can not both be provided',\n\n    // Pedantic Mode support\n    //Q_SUB = /^([^\\.\\*>\\s]+|>$|\\*)(\\.([^\\.\\*>\\s]+|>$|\\*))*$/, // TODO: remove / never used\n    //Q_SUB_NO_WC = /^([^\\.\\*>\\s]+)(\\.([^\\.\\*>\\s]+))*$/, // TODO: remove / never used\n\n    FLUSH_THRESHOLD = 65536;\n\n/**\n * Library Version\n */\n\nexports.version = VERSION;\n\n/**\n * Create a properly formatted inbox subject.\n *\n * @api public\n*/\n\nvar createInbox = exports.createInbox = function() {\n  return (\"_INBOX.\" + nuid.next());\n};\n\n/**\n * Initialize a client with the appropriate options.\n *\n * @param {Mixed} opts\n * @api public\n */\n\nfunction Client(opts) {\n  events.EventEmitter.call(this);\n  this.parseOptions(opts);\n  this.initState();\n  this.createConnection();\n}\n\n/**\n * Connect to a nats-server and return the client.\n * Argument can be a url, or an object with a 'url'\n * property and additional options.\n *\n * @params {Mixed} opts\n *\n * @api public\n */\n\nexports.connect = function(opts) {\n  return new Client(opts);\n};\n\n/**\n * Connected clients are event emitters.\n */\n\nutil.inherits(Client, events.EventEmitter);\n\n/**\n * Allow createInbox to be called on a client.\n *\n * @api public\n */\n\nClient.prototype.createInbox = createInbox;\n\nClient.prototype.assignOption = function(opts, prop, assign) {\n  if (assign === undefined) {\n    assign = prop;\n  }\n  if (opts[prop] !== undefined) {\n    this.options[assign] = opts[prop];\n  }\n};\n\nfunction shuffle(array) {\n  for (var i = array.length - 1; i > 0; i--) {\n    var j = Math.floor(Math.random() * (i + 1));\n    var temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n  }\n  return array;\n}\n\n/**\n * Parse the conctructor/connect options.\n *\n * @param {Mixed} opts\n * @api private\n */\n\nClient.prototype.parseOptions = function(opts) {\n  var options = this.options = {\n    'verbose'              : false,\n    'pedantic'             : false,\n    'reconnect'            : true,\n    'maxReconnectAttempts' : DEFAULT_MAX_RECONNECT_ATTEMPTS,\n    'reconnectTimeWait'    : DEFAULT_RECONNECT_TIME_WAIT,\n    'encoding'             : 'utf8',\n    'tls'                  : false,\n    'waitOnFirstConnect'   : false,\n  };\n\n  if (undefined === opts) {\n    options.url = DEFAULT_URI;\n  } else if ('number' === typeof opts) {\n    options.url = DEFAULT_PRE + opts;\n  } else if ('string' === typeof opts) {\n    options.url = opts;\n  } else if ('object' === typeof opts) {\n    if (opts.port !== undefined) {\n      options.url = DEFAULT_PRE + opts.port;\n    }\n    // Pull out various options here\n    this.assignOption(opts, 'url');\n    this.assignOption(opts, 'uri', 'url');\n    this.assignOption(opts, 'user');\n    this.assignOption(opts, 'pass');\n    this.assignOption(opts, 'token');\n    this.assignOption(opts, 'password', 'pass');\n    this.assignOption(opts, 'verbose');\n    this.assignOption(opts, 'pedantic');\n    this.assignOption(opts, 'reconnect');\n    this.assignOption(opts, 'maxReconnectAttempts');\n    this.assignOption(opts, 'reconnectTimeWait');\n    this.assignOption(opts, 'servers');\n    this.assignOption(opts, 'urls', 'servers');\n    this.assignOption(opts, 'noRandomize');\n    this.assignOption(opts, 'NoRandomize', 'noRandomize');\n    this.assignOption(opts, 'dontRandomize', 'noRandomize');\n    this.assignOption(opts, 'encoding');\n    this.assignOption(opts, 'tls');\n    this.assignOption(opts, 'secure', 'tls');\n    this.assignOption(opts, 'name');\n    this.assignOption(opts, 'client', 'name');\n    this.assignOption(opts, 'yieldTime');\n    this.assignOption(opts, 'waitOnFirstConnect');\n    this.assignOption(opts, 'json');\n  }\n\n  var client = this;\n\n  // Set user/pass as needed if in options.\n  client.user = options.user;\n  client.pass = options.pass;\n  \n  // Set token as needed if in options.\n  client.token = options.token;\n\n  // Authentication - make sure authentication is valid.\n  if (client.user && client.token) {\n    throw(new Error(BAD_AUTHENTICATION));\n  }\n\n  // Encoding - make sure its valid.\n  if (Buffer.isEncoding(options.encoding)) {\n    client.encoding = options.encoding;\n  } else {\n    throw new Error('Invalid Encoding:' + options.encoding);\n  }\n  // For cluster support\n  client.servers = [];\n\n  if (Array.isArray(options.servers)) {\n    options.servers.forEach(function(server) {\n      client.servers.push(new Server(url.parse(server)));\n    });\n  } else {\n    if (undefined === options.url) {\n      options.url = DEFAULT_URI;\n    }\n    client.servers.push(new Server(url.parse(options.url)));\n  }\n\n  // Randomize if needed\n  if (options.noRandomize !==  true) {\n    shuffle(client.servers);\n  }\n};\n\n/**\n * Create a new server.\n *\n * @api private\n*/\n\nfunction Server(url) {\n  this.url = url;\n  this.didConnect = false;\n  this.reconnects = 0;\n}\n\n/**\n * Properly select the next server.\n * We rotate the server list as we go,\n * we also pull auth from urls as needed, or\n * if they were set in options use that as override.\n *\n * @api private\n*/\n\nClient.prototype.selectServer = function() {\n  var client = this;\n  var server = client.servers.shift();\n\n  // Place in client context.\n  client.currentServer = server;\n  client.url = server.url;\n  if ('auth' in server.url && !!server.url.auth) {\n    var auth = server.url.auth.split(':');\n    if (auth.length !== 1) {\n      if (client.options.user === undefined) {\n        client.user = auth[0];\n      }\n      if (client.options.pass === undefined) {\n        client.pass = auth[1];\n      }\n    } else {\n      if (client.options.token === undefined) {\n        client.token = auth[0];\n      }\n    }\n  }\n  client.servers.push(server);\n};\n\n/**\n * Check for TLS configuration mismatch.\n *\n * @api private\n*/\n\nClient.prototype.checkTLSMismatch = function() {\n  if (this.info.tls_required === true &&\n      this.options.tls === false) {\n    this.emit('error', 'Server requires a secure connection.');\n    this.closeStream();\n    return true;\n  }\n\n  if (this.info.tls_required === false &&\n      this.options.tls !== false) {\n    this.emit('error', 'Server does not support a secure connection.');\n    this.closeStream();\n    return true;\n  }\n\n  if (this.info.tls_verify === true &&\n      this.options.tls.cert === undefined) {\n    this.emit('error', 'Server requires a client certificate.');\n    this.closeStream();\n    return true;\n  }\n  return false;\n};\n\n/**\n * Callback for first flush/connect.\n *\n * @api private\n*/\n\nClient.prototype.connectCB = function() {\n  var wasReconnecting = this.reconnecting;\n  var event = (wasReconnecting === true) ? 'reconnect' : 'connect';\n  this.reconnecting = false;\n  this.reconnects = 0;\n  this.wasConnected = true;\n  this.currentServer.didConnect = true;\n\n  this.emit(event, this);\n\n  this.flushPending();\n};\n\n\n/**\n * Properly setup a stream event handlers.\n *\n * @api private\n*/\n\nClient.prototype.setupHandlers = function() {\n  var client = this;\n  var stream = client.stream;\n\n  if (undefined === stream) {\n    return;\n  }\n\n  stream.on('connect', function() {\n    client.connected = true;\n  });\n\n  stream.on('close', function(hadError) {\n    client.closeStream();\n    client.emit('disconnect');\n    if (client.closed === true ||\n        client.options.reconnect === false ||\n        ((client.reconnects >= client.options.maxReconnectAttempts) && client.options.maxReconnectAttempts !== -1)) {\n      client.emit('close');\n    } else {\n      client.scheduleReconnect();\n    }\n  });\n\n  stream.on('error', function(exception) {\n    // If we were connected just return, close event will process\n    if (client.wasConnected === true && client.currentServer.didConnect === true) {\n      return;\n    }\n\n    // if the current server did not connect at all, and we in\n    // general have not connected to any server, remove it from\n    // this list. Unless overidden\n    if (client.wasConnected === false && client.currentServer.didConnect === false) {\n      // We can override this behavior with waitOnFirstConnect, which will\n      // treat it like a reconnect scenario.\n      if (client.options.waitOnFirstConnect) {\n\t// Pretend to move us into a reconnect state.\n\tclient.currentServer.didConnect\t= true;\n      } else {\n\tclient.servers.splice(client.servers.length-1, 1);\n      }\n    }\n\n    // Only bubble up error if we never had connected\n    // to the server and we only have one.\n    if (client.wasConnected === false && client.servers.length === 0) {\n      client.emit('error', 'Could not connect to server: ' + exception);\n    }\n    client.closeStream();\n  });\n\n  stream.on('data', function (data) {\n    // If inbound exists, concat them together. We try to avoid this for split\n    // messages, so this should only really happen for a split control line.\n    // Long term answer is hand rolled parser and not regexp.\n    if (client.inbound) {\n      client.inbound = Buffer.concat([client.inbound, data]);\n    } else {\n      client.inbound = data;\n    }\n\n    // Process the inbound queue.\n    client.processInbound();\n  });\n};\n\n/**\n * Send the connect command. This needs to happen after receiving the first\n * INFO message and after TLS is established if necessary.\n *\n * @api private\n*/\n\nClient.prototype.sendConnect = function() {\n  // Queue the connect command.\n  var cs = {\n    'lang'    : 'node',\n    'version' : VERSION,\n    'verbose' : this.options.verbose,\n    'pedantic': this.options.pedantic\n  };\n  if (this.user !== undefined) {\n    cs.user = this.user;\n    cs.pass = this.pass;\n  }\n  if (this.token !== undefined) {\n    cs.auth_token = this.token;\n  }\n  if (this.options.name !== undefined) {\n    cs.name = this.options.name;\n  }\n\n  // If we enqueued requests before we received INFO from the server, or we\n  // reconnected, there be other data pending, write this immediately instead\n  // of adding it to the queue.\n  this.stream.write(CONNECT + SPC + JSON.stringify(cs) + CR_LF);\n};\n\n/**\n * Properly setup a stream connection with proper events.\n *\n * @api private\n*/\n\nClient.prototype.createConnection = function() {\n  // Commands may have been queued during reconnect. Discard everything except:\n  // 1) ping requests with a pong callback\n  // 2) publish requests\n  //\n  // Rationale: CONNECT and SUBs are written directly upon connecting, any PONG\n  // response is no longer relevant, and any UNSUB will be accounted for when we\n  // sync our SUBs. Without this, users of the client may miss state transitions\n  // via callbacks, would have to track the client's internal connection state,\n  // and may have to double buffer messages (which we are already doing) if they\n  // wanted to ensure their messages reach the server.\n  var pong = [];\n  var pend = [];\n  var pSize = 0;\n  var client = this;\n  if (client.pending !== null) {\n    var pongIndex = 0;\n    client.pending.forEach(function(cmd) {\n      var cmdLen = Buffer.isBuffer(cmd) ? cmd.length : Buffer.byteLength(cmd);\n      if (cmd === PING_REQUEST && client.pongs !== null && pongIndex < client.pongs.length) {\n        // filter out any useless ping requests (no pong callback, nop flush)\n        var p = client.pongs[pongIndex++];\n        if (p !== undefined) {\n          pend.push(cmd);\n          pSize += cmdLen;\n          pong.push(p);\n        }\n      } else if (cmd.length > 3 && cmd[0] == 'P' && cmd[1] == 'U' && cmd[2] == 'B') {\n        pend.push(cmd);\n        pSize += cmdLen;\n      }\n    });\n  }\n  this.pongs   = pong;\n  this.pending = pend;\n  this.pSize   = pSize;\n\n  this.pstate  = AWAITING_CONTROL;\n\n  // Clear info processing.\n  this.info         = null;\n  this.infoReceived = false;\n\n  // Select a server to connect to.\n  this.selectServer();\n  // Create the stream.\n  this.stream = net.createConnection(this.url);\n  // Setup the proper handlers.\n  this.setupHandlers();\n};\n\n/**\n * Initialize client state.\n *\n * @api private\n */\n\nClient.prototype.initState = function() {\n  this.ssid         = 1;\n  this.subs         = {};\n  this.reconnects   = 0;\n  this.connected    = false;\n  this.wasConnected = false;\n  this.reconnecting = false;\n  this.server       = null;\n  this.pending      = [];\n};\n\n/**\n * Close the connection to the server.\n *\n * @api public\n */\n\nClient.prototype.close = function() {\n  this.closed = true;\n  this.removeAllListeners();\n  this.closeStream();\n  this.ssid     = -1;\n  this.subs     = null;\n  this.pstate   = -1;\n  this.pongs    = null;\n  this.pending  = null;\n  this.pSize    = 0;\n};\n\n/**\n * Close down the stream and clear state.\n *\n * @api private\n */\n\nClient.prototype.closeStream = function() {\n  if (this.stream !== null) {\n    this.stream.end();\n    this.stream.destroy();\n    this.stream  = null;\n  }\n  if (this.connected === true || this.closed === true) {\n    this.pongs     = null;\n    this.pending   = null;\n    this.pSize     = 0;\n    this.connected = false;\n  }\n  this.inbound = null;\n};\n\n/**\n * Flush all pending data to the server.\n *\n * @api private\n */\n\nClient.prototype.flushPending = function() {\n  if (this.connected === false ||\n      this.pending === null ||\n      this.pending.length === 0 ||\n      this.infoReceived !== true) {\n    return;\n  }\n\n  var client = this;\n  var write = function(data) {\n    client.pending = [];\n    client.pSize = 0;\n    return client.stream.write(data);\n  };\n  if (!this.pBufs) {\n    // All strings, fastest for now.\n    return write(this.pending.join(EMPTY));\n  } else {\n    // We have some or all Buffers. Figure out if we can optimize.\n    var allBufs = true;\n    for (var i=0; i < this.pending.length; i++){\n      if (!Buffer.isBuffer(this.pending[i])) {\n\tallBufs = false;\n\tbreak;\n      }\n    }\n    // If all buffers, concat together and write once.\n    if (allBufs) {\n      return write(Buffer.concat(this.pending, this.pSize));\n    } else {\n      // We have a mix, so write each one individually.\n      var pending = this.pending;\n      this.pending = [];\n      this.pSize = 0;\n      var result = true;\n      for (i=0; i < pending.length; i++){\n\t      result = this.stream.write(pending[i]) && result;\n      }\n      return result;\n    }\n  }\n};\n\n/**\n * Strips all SUBS commands from pending during initial connection completed since\n * we send the subscriptions as a separate operation.\n *\n * @api private\n */\n\nClient.prototype.stripPendingSubs = function() {\n  var pending = this.pending;\n  this.pending = [];\n  this.pSize = 0;\n  for (var i=0; i < pending.length; i++){\n    if (!SUBRE.test(pending[i])) {\n      // Re-queue the command.\n      this.sendCommand(pending[i]);\n    }\n  }\n};\n\n/**\n * Send commands to the server or queue them up if connection pending.\n *\n * @api private\n */\n\nClient.prototype.sendCommand = function(cmd) {\n  // Buffer to cut down on system calls, increase throughput.\n  // When receive gets faster, should make this Buffer based..\n\n  if (this.closed || this.pending === null) { return; }\n\n  this.pending.push(cmd);\n  if (!Buffer.isBuffer(cmd)) {\n    this.pSize += Buffer.byteLength(cmd);\n  } else {\n    this.pSize += cmd.length;\n    this.pBufs = true;\n  }\n\n  if (this.connected === true) {\n    // First one let's setup flush..\n    if (this.pending.length === 1) {\n      var self = this;\n      setImmediate(function() {\n        self.flushPending();\n      });\n    } else if (this.pSize > FLUSH_THRESHOLD) {\n      // Flush in place when threshold reached..\n      this.flushPending();\n    }\n  }\n};\n\n/**\n * Sends existing subscriptions to new server after reconnect.\n *\n * @api private\n */\n\nClient.prototype.sendSubscriptions = function() {\n  var protos = \"\";\n  for (var sid in this.subs) {\n    if (this.subs.hasOwnProperty(sid)) {\n      var sub = this.subs[sid];\n      var proto;\n      if (sub.qgroup) {\n\tproto = [SUB, sub.subject, sub.qgroup, sid + CR_LF];\n      } else {\n\tproto = [SUB, sub.subject, sid + CR_LF];\n      }\n      protos += proto.join(SPC);\n    }\n  }\n  if (protos.length > 0) {\n    this.stream.write(protos);\n  }\n};\n\n/**\n * Process the inbound data queue.\n *\n * @api private\n */\n\nClient.prototype.processInbound = function() {\n  var client = this;\n\n  // Hold any regex matches.\n  var m;\n\n  // For optional yield\n  var start;\n\n  // unpause if needed.\n  // FIXME(dlc) client.stream.isPaused() causes 0.10 to fail\n  client.stream.resume();\n\n  /* jshint -W083 */\n\n  if (client.options.yieldTime !== undefined) {\n    start = Date.now();\n  }\n\n  while (!client.closed && client.inbound && client.inbound.length > 0) {\n    switch (client.pstate) {\n\n    case AWAITING_CONTROL:\n      // Regex only works on strings, so convert once to be more efficient.\n      // Long term answer is a hand rolled parser, not regex.\n      var buf = client.inbound.toString('binary', 0, MAX_CONTROL_LINE_SIZE);\n      if ((m = MSG.exec(buf)) !== null) {\n        client.payload = {\n          subj : m[1],\n          sid : parseInt(m[2], 10),\n          reply : m[4],\n          size : parseInt(m[5], 10)\n        };\n\tclient.payload.psize = client.payload.size + CR_LF_LEN;\n        client.pstate = AWAITING_MSG_PAYLOAD;\n      } else if ((m = OK.exec(buf)) !== null) {\n        // Ignore for now..\n      } else if ((m = ERR.exec(buf)) !== null) {\n        client.emit('error', m[1]);\n      } else if ((m = PONG.exec(buf)) !== null) {\n        var cb = client.pongs && client.pongs.shift();\n        if (cb) { cb(); } // FIXME: Should we check for exceptions?\n      } else if ((m = PING.exec(buf)) !== null) {\n        client.sendCommand(PONG_RESPONSE);\n      } else if ((m = INFO.exec(buf)) !== null) {\n\tclient.info = JSON.parse(m[1]);\n\t// Check on TLS mismatch.\n\tif (client.checkTLSMismatch() === true) {\n\t  return;\n\t}\n\t// Process first INFO\n\tif (client.infoReceived === false) {\n\t  // Switch over to TLS as needed.\n\t  if (client.options.tls !== false &&\n\t      client.stream.encrypted !== true) {\n\t    var tlsOpts = {socket: client.stream};\n\t    if ('object' === typeof client.options.tls) {\n\t      for (var key in client.options.tls) {\n\t\ttlsOpts[key] = client.options.tls[key];\n\t      }\n\t    }\n\t    client.stream = tls.connect(tlsOpts, function() {\n\t      client.flushPending();\n\t    });\n\t    client.setupHandlers();\n\t  }\n\n\t  // Send the connect message and subscriptions immediately\n\t  client.sendConnect();\n\t  client.sendSubscriptions();\n\n\t  client.pongs.unshift(function() { client.connectCB(); });\n\t  client.stream.write(PING_REQUEST);\n\n\t  // Mark as received\n\t  client.infoReceived = true;\n\t  client.stripPendingSubs();\n\t  client.flushPending();\n\t}\n      } else {\n        // FIXME, check line length for something weird.\n        // Nothing here yet, return\n        return;\n      }\n      break;\n\n    case AWAITING_MSG_PAYLOAD:\n\n      // If we do not have the complete message, hold onto the chunks\n      // and assemble when we have all we need. This optimizes for\n      // when we parse a large buffer down to a small number of bytes,\n      // then we receive a large chunk. This avoids a big copy with a\n      // simple concat above.\n      if (client.inbound.length < client.payload.psize) {\n\tif (undefined === client.payload.chunks) {\n\t  client.payload.chunks = [];\n\t}\n\tclient.payload.chunks.push(client.inbound);\n\tclient.payload.psize -= client.inbound.length;\n        client.inbound = null;\n\treturn;\n      }\n\n      // If we are here we have the complete message.\n      // Check to see if we have existing chunks\n      if (client.payload.chunks) {\n\tclient.payload.chunks.push(client.inbound.slice(0, client.payload.psize));\n\tvar mbuf = Buffer.concat(client.payload.chunks, client.payload.size+CR_LF_LEN);\n\tclient.payload.msg = mbuf.toString(client.encoding, 0, client.payload.size);\n      } else {\n\tclient.payload.msg = client.inbound.toString(client.encoding, 0, client.payload.size);\n      }\n\n      // Eat the size of the inbound that represents the message.\n      if (client.inbound.length === client.payload.psize) {\n        client.inbound = null;\n      } else {\n        client.inbound = client.inbound.slice(client.payload.psize);\n      }\n\n      // process the message\n      client.processMsg();\n\n      // Reset\n      client.pstate = AWAITING_CONTROL;\n      client.payload = null;\n\n      // Check to see if we have an option to yield for other events after yieldTime.\n      if (start !== undefined) {\n\tif ((Date.now() - start) > client.options.yieldTime) {\n\t  client.stream.pause();\n\t  setImmediate(client.processInbound.bind(this));\n\t  return;\n\t}\n      }\n      break;\n    }\n\n    // This is applicable for a regex match to eat the bytes we used from a control line.\n    if (m && !this.closed) {\n      // Chop inbound\n      var psize = m[0].length;\n      if (psize >= client.inbound.length) {\n        client.inbound = null;\n      } else {\n        client.inbound = client.inbound.slice(psize);\n      }\n    }\n    m = null;\n  }\n};\n\n/**\n * Process a delivered message and deliver to appropriate subscriber.\n *\n * @api private\n */\n\nClient.prototype.processMsg = function() {\n  var sub = this.subs[this.payload.sid];\n  if (sub !== undefined) {\n    sub.received += 1;\n    // Check for a timeout, and cancel if received >= expected\n    if (sub.timeout) {\n      if (sub.received >= sub.expected) {\n        clearTimeout(sub.timeout);\n        sub.timeout = null;\n      }\n    }\n    // Check for auto-unsubscribe\n    if (sub.max !== undefined) {\n      if (sub.received === sub.max) {\n        delete this.subs[this.payload.sid];\n\tthis.emit('unsubscribe', this.payload.sid, sub.subject);\n      } else if (sub.received > sub.max) {\n        this.unsubscribe(this.payload.sid);\n        sub.callback = null;\n      }\n    }\n\n    if (sub.callback) {\n      var msg = this.payload.msg;\n      if (this.options.json) {\n        try {\n          msg = JSON.parse(new Buffer(this.payload.msg, this.options.encoding).toString());\n        } catch (e) {\n          msg = e;\n        }\n      }\n      sub.callback(msg, this.payload.reply, this.payload.subj, this.payload.sid);\n    }\n  }\n};\n\n/**\n * Push a new cluster server.\n *\n * @param {String} uri\n * @api public\n*/\n\nClient.prototype.addServer = function(uri) {\n  this.servers.push(new Server(url.parse(uri)));\n\n  if (this.options.noRandomize !==  true) {\n    shuffle(this.servers);\n  }\n};\n\n/**\n * Flush outbound queue to server and call optional callback when server has processed\n * all data.\n *\n * @param {Function} opt_callback\n * @api public\n */\n\nClient.prototype.flush = function(opt_callback) {\n  if (this.closed) {\n    if (typeof opt_callback === 'function') {\n      opt_callback(new Error(CONN_CLOSED));\n      return;\n    } else {\n      throw(new Error(CONN_CLOSED));\n    }\n  }\n  if (this.pongs) {\n    this.pongs.push(opt_callback);\n    this.sendCommand(PING_REQUEST);\n    this.flushPending();\n  }\n};\n\n/**\n * Publish a message to the given subject, with optional reply and callback.\n *\n * @param {String} subject\n * @param {String} opt_msg\n * @param {String} opt_reply\n * @param {Function} opt_callback\n * @api public\n */\n\nClient.prototype.publish = function(subject, msg, opt_reply, opt_callback) {\n  // They only supplied a callback function.\n  if (typeof subject === 'function') {\n    opt_callback = subject;\n    subject = undefined;\n  }\n  if (!msg) { msg = EMPTY; }\n  if (!subject) {\n    if (opt_callback) {\n      opt_callback(new Error(BAD_SUBJECT));\n    } else {\n      throw(new Error(BAD_SUBJECT));\n    }\n  }\n  if (typeof msg === 'function') {\n    if (opt_callback || opt_reply) {\n      opt_callback(new Error(BAD_MSG));\n      return;\n    }\n    opt_callback = msg;\n    msg = EMPTY;\n    opt_reply = undefined;\n  }\n  if (typeof opt_reply === 'function') {\n    if (opt_callback) {\n      opt_callback(new Error(BAD_REPLY));\n      return;\n    }\n    opt_callback = opt_reply;\n    opt_reply = undefined;\n  }\n\n  // Hold PUB SUB [REPLY]\n  var psub;\n  if (opt_reply === undefined) {\n    psub = 'PUB ' + subject + SPC;\n  } else {\n    psub = 'PUB ' + subject + SPC + opt_reply + SPC;\n  }\n\n  if ('ArrayBuffer' in window && ArrayBuffer.isView(msg)) {\n    msg = Buffer.from(msg);\n  }\n\n  // Need to treat sending buffers different.\n  if (!Buffer.isBuffer(msg)) {\n    var str = msg;\n    if (this.options.json) {\n      if (typeof msg !== 'object' || Array.isArray(msg)) {\n        throw(new Error(BAD_JSON_MSG));\n      }\n      try {\n        str = JSON.stringify(msg);\n      } catch (e) {\n        throw(new Error(BAD_JSON_MSG));\n      }\n    }\n    this.sendCommand(psub + Buffer.byteLength(str) + CR_LF + str + CR_LF);\n  } else {\n    var b = new Buffer(psub.length + msg.length + (2 * CR_LF_LEN) + msg.length.toString().length);\n    var len = b.write(psub + msg.length + CR_LF);\n    msg.copy(b, len);\n    b.write(CR_LF, len + msg.length);\n    this.sendCommand(b);\n  }\n\n  if (opt_callback !== undefined) {\n    this.flush(opt_callback);\n  } else if (this.closed) {\n    throw(new Error(CONN_CLOSED));\n  }\n};\n\n/**\n * Subscribe to a given subject, with optional options and callback. opts can be\n * ommitted, even with a callback. The Subscriber Id is returned.\n *\n * @param {String} subject\n * @param {Object} opts\n * @param {Function} callback\n * @return {Mixed}\n * @api public\n */\n\nClient.prototype.subscribe = function(subject, opts, callback) {\n  if (this.closed) {\n    throw(new Error(CONN_CLOSED));\n  }\n  var qgroup, max;\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = undefined;\n  } else if (opts && typeof opts === 'object') {\n    // FIXME, check exists, error otherwise..\n    qgroup = opts.queue;\n    max = opts.max;\n  }\n  this.ssid += 1;\n  this.subs[this.ssid] = { 'subject':subject, 'callback':callback, 'received':0 };\n\n  var proto;\n  if (typeof qgroup === 'string') {\n    this.subs[this.ssid].qgroup = qgroup;\n    proto = [SUB, subject, qgroup, this.ssid + CR_LF];\n  } else {\n    proto = [SUB, subject, this.ssid + CR_LF];\n  }\n\n  this.sendCommand(proto.join(SPC));\n  this.emit('subscribe', this.ssid, subject, opts);\n\n  if (max) {\n    this.unsubscribe(this.ssid, max);\n  }\n  return this.ssid;\n};\n\n/**\n * Unsubscribe to a given Subscriber Id, with optional max parameter.\n *\n * @param {Mixed} sid\n * @param {Number} opt_max\n * @api public\n */\n\nClient.prototype.unsubscribe = function(sid, opt_max) {\n  if (!sid || this.closed) { return; }\n\n  var proto;\n  if (opt_max) {\n    proto = [UNSUB, sid, opt_max + CR_LF];\n  } else {\n    proto = [UNSUB, sid + CR_LF];\n  }\n  this.sendCommand(proto.join(SPC));\n\n  var sub = this.subs[sid];\n  if (sub === undefined) {\n    return;\n  }\n  sub.max = opt_max;\n  if (sub.max === undefined || (sub.received >= sub.max)) {\n    delete this.subs[sid];\n    this.emit('unsubscribe', sid, sub.subject);\n  }\n};\n\n/**\n * Set a timeout on a subscription.\n *\n * @param {Mixed} sid\n * @param {Number} timeout\n * @param {Number} expected\n * @api public\n */\n\nClient.prototype.timeout = function(sid, timeout, expected, callback) {\n  if (!sid) { return; }\n  var sub = this.subs[sid];\n  if (sub === null) { return; }\n  sub.expected = expected;\n  sub.timeout = setTimeout(function() { callback(sid); }, timeout);\n};\n\n/**\n * Publish a message with an implicit inbox listener as the reply. Message is optional.\n * This should be treated as a subscription. You can optionally indicate how many\n * messages you only want to receive using opt_options = {max:N}. Otherwise you\n * will need to unsubscribe to stop the message stream.\n * The Subscriber Id is returned.\n *\n * @param {String} subject\n * @param {String} opt_msg\n * @param {Object} opt_options\n * @param {Function} callback\n * @return {Mixed}\n * @api public\n */\n\nClient.prototype.request = function(subject, opt_msg, opt_options, callback) {\n  if (typeof opt_msg === 'function') {\n    callback = opt_msg;\n    opt_msg = EMPTY;\n    opt_options = null;\n  }\n  if (typeof opt_options === 'function') {\n    callback = opt_options;\n    opt_options = null;\n  }\n  var inbox = createInbox();\n  var s = this.subscribe(inbox, opt_options, function(msg, reply) {\n    callback(msg, reply);\n  });\n  this.publish(subject, opt_msg, inbox);\n  return s;\n};\n\n/**\n * Report number of outstanding subscriptions on this connection.\n *\n * @return {Number}\n * @api public\n */\n\nClient.prototype.numSubscriptions = function() {\n  return Object.keys(this.subs).length;\n};\n\n/**\n * Reconnect to the server.\n *\n * @api private\n */\n\nClient.prototype.reconnect = function() {\n  if (this.closed) { return; }\n  this.reconnects += 1;\n  this.createConnection();\n  if (this.currentServer.didConnect === true) {\n    this.emit('reconnecting');\n  }\n};\n\n/**\n * Setup a timer event to attempt reconnect.\n *\n * @api private\n */\n\nClient.prototype.scheduleReconnect = function() {\n  var client = this;\n  // Just return if no more servers\n  if (client.servers.length === 0) {\n    return;\n  }\n  // Don't set reconnecting state if we are just trying\n  // for the first time.\n  if (client.wasConnected === true) {\n    client.reconnecting = true;\n  }\n  // Only stall if we have connected before.\n  var wait = 0;\n  if (client.servers[0].didConnect === true) {\n    wait = this.options.reconnectTimeWait;\n  }\n  setTimeout(function() { client.reconnect(); }, wait);\n};\n","'use strict';\n\nvar util = require('util');\nvar EventEmitter = require('events').EventEmitter;\n\nfunction WebSocketProxy(url) {\n\tvar self = this;\n\tEventEmitter.call(this);\n\tthis.sock = new WebSocket(url);\n\tthis.sock.addEventListener('open', function(e) {\n\t\tself.emit('connect');\n\t});\n\tthis.sock.addEventListener('message', function(e) {\n\t\tself.emit('data', new Buffer(e.data));\n\t});\n\tthis.sock.addEventListener('error', function(e) {\n\t\tself.emit('error', e);\n\t});\n\tthis.sock.addEventListener('close', function(e) {\n\t\tself.emit('close');\n\t});\n}\nutil.inherits(WebSocketProxy, EventEmitter);\n\nWebSocketProxy.prototype.end = function() {\n\tthis.destroy();\n}\n\nWebSocketProxy.prototype.destroy = function() {\n\tif (\n\t\tthis.sock.readyState === WebSocket.CONNECTING ||\n\t\tthis.sock.readyState === WebSocket.OPEN\n\t) {\n\t\tthis.sock.close();\n\t}\n}\n\nWebSocketProxy.prototype.write = function(data) {\n\tif (this.sock.readyState === WebSocket.OPEN) {\n\t\tthis.sock.send(data);\n\t}\n}\n\nWebSocketProxy.prototype.pause = function() {\n\tconsole.warn('WebSocketProxy stream pause/resume is not supported yet.');\n}\n\nWebSocketProxy.prototype.resume = function() {}\n\nexports.createConnection = function(url) {\n\t// The url is rebuilt to avoid including the auth credentials.\n\treturn new WebSocketProxy(url.format({\n\t\tprotocol:  url.protocol,\n\t\tslashes:   url.slashes,\n\t\thost:      url.host,\n\t\thostname:  url.hostname,\n\t\tport:      url.port,\n\t\tpathname:  url.pathname,\n\t\tsearch:    url.search,\n\t\tpath:      url.path,\n\t\tquery:     url.query,\n\t\thash:      url.hash\n\t}));\n}\n","exports.connect = function(opts, cb) {\n\tthrow \"TLS is not supported in the browser. Use WSS instead.\";\n}\n"],"sourceRoot":""}