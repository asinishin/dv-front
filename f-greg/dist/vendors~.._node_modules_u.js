(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendors~.._node_modules_u"],{

/***/ "../node_modules/util-deprecate/browser.js":
/*!*************************************************!*\
  !*** ../node_modules/util-deprecate/browser.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {
/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../node_modules/util/node_modules/inherits/inherits_browser.js":
/*!**********************************************************************!*\
  !*** ../node_modules/util/node_modules/inherits/inherits_browser.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),

/***/ "../node_modules/util/support/isBufferBrowser.js":
/*!*******************************************************!*\
  !*** ../node_modules/util/support/isBufferBrowser.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}

/***/ }),

/***/ "../node_modules/util/util.js":
/*!************************************!*\
  !*** ../node_modules/util/util.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, Promise) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
  function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};
    for (var i = 0; i < keys.length; i++) {
      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return descriptors;
  };

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  if (typeof process !== 'undefined' && process.noDeprecation === true) {
    return fn;
  }

  // Allow for deprecating things in the process of starting up.
  if (typeof process === 'undefined') {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ "../node_modules/util/support/isBufferBrowser.js");

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = __webpack_require__(/*! inherits */ "../node_modules/util/node_modules/inherits/inherits_browser.js");

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function')
    throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];
    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn, enumerable: false, writable: false, configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });

    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }
    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn, enumerable: false, writable: false, configurable: true
  });
  return Object.defineProperties(
    fn,
    getOwnPropertyDescriptors(original)
  );
}

exports.promisify.custom = kCustomPromisifiedSymbol

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }
  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  }

  // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.
  function callbackified() {
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();
    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }
    var self = this;
    var cb = function() {
      return maybeCb.apply(self, arguments);
    };
    // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)
    original.apply(this, args)
      .then(function(ret) { process.nextTick(cb, null, ret) },
            function(rej) { process.nextTick(callbackifyOnRejected, rej, cb) });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified,
                          getOwnPropertyDescriptors(original));
  return callbackified;
}
exports.callbackify = callbackify;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "../node_modules/process/browser.js"), __webpack_require__(/*! core-js/es/promise */ "../node_modules/core-js/es/promise/index.js")))

/***/ }),

/***/ "../node_modules/webpack/buildin/amd-options.js":
/*!******************************************************!*\
  !*** ../node_modules/webpack/buildin/amd-options.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(this, {}))

/***/ }),

/***/ "../node_modules/webpack/buildin/global.js":
/*!*************************************************!*\
  !*** ../node_modules/webpack/buildin/global.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "../node_modules/webpack/buildin/harmony-module.js":
/*!*********************************************************!*\
  !*** ../node_modules/webpack/buildin/harmony-module.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(originalModule) {
	if (!originalModule.webpackPolyfill) {
		var module = Object.create(originalModule);
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		Object.defineProperty(module, "exports", {
			enumerable: true
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "../node_modules/webpack/buildin/module.js":
/*!*************************************************!*\
  !*** ../node_modules/webpack/buildin/module.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "../node_modules/websocket-nats/index.js":
/*!***********************************************!*\
  !*** ../node_modules/websocket-nats/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./lib/nats */ "../node_modules/websocket-nats/lib/nats.js");


/***/ }),

/***/ "../node_modules/websocket-nats/lib/nats.js":
/*!**************************************************!*\
  !*** ../node_modules/websocket-nats/lib/nats.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer, setImmediate) {/*!
 * Nats
 * Copyright(c) 2012-2016 Apcera Inc. All rights reserved.
 * Copyright(c) 2011-2014 Derek Collison (derek.collison@gmail.com)
 * MIT Licensed
 */

/* jslint node: true */


/**
 * Module Dependencies
 */

var net    = __webpack_require__(/*! net */ "../node_modules/websocket-nats/lib/net.js"),
    tls    = __webpack_require__(/*! tls */ "../node_modules/websocket-nats/lib/tls.js"),
    url    = __webpack_require__(/*! url */ "../node_modules/url/url.js"),
    util   = __webpack_require__(/*! util */ "../node_modules/util/util.js"),
    events = __webpack_require__(/*! events */ "../node_modules/events/events.js"),
    nuid   = __webpack_require__(/*! nuid */ "../node_modules/nuid/index.js");

/**
 * Constants
 */

var VERSION = '0.6.8',

    DEFAULT_PORT = 4222,
    DEFAULT_PRE  = 'nats://localhost:',
    DEFAULT_URI  =  DEFAULT_PRE + DEFAULT_PORT,

    MAX_CONTROL_LINE_SIZE = 512,

    // Parser state
    AWAITING_CONTROL = 0,
    AWAITING_MSG_PAYLOAD = 1,

    // Reconnect Parameters, 2 sec wait, 10 tries
    DEFAULT_RECONNECT_TIME_WAIT = 2*1000,
    DEFAULT_MAX_RECONNECT_ATTEMPTS = 10,

    // Protocol
    //CONTROL_LINE = /^(.*)\r\n/, // TODO: remove / never used

    MSG   = /^MSG\s+([^\s\r\n]+)\s+([^\s\r\n]+)\s+(([^\s\r\n]+)[^\S\r\n]+)?(\d+)\r\n/i,
    OK    = /^\+OK\s*\r\n/i,
    ERR   = /^-ERR\s+('.+')?\r\n/i,
    PING  = /^PING\r\n/i,
    PONG  = /^PONG\r\n/i,
    INFO  = /^INFO\s+([^\r\n]+)\r\n/i,
    SUBRE = /^SUB\s+([^\r\n]+)\r\n/i,

    CR_LF = '\r\n',
    CR_LF_LEN = CR_LF.length,
    EMPTY = '',
    SPC = ' ',

    // Protocol
    //PUB     = 'PUB', // TODO: remove / never used
    SUB     = 'SUB',
    UNSUB   = 'UNSUB',
    CONNECT = 'CONNECT',

    // Responses
    PING_REQUEST  = 'PING' + CR_LF,
    PONG_RESPONSE = 'PONG' + CR_LF,

    // Errors
    BAD_SUBJECT = 'Subject must be supplied',
    BAD_MSG = 'Message can\'t be a function',
    BAD_REPLY = 'Reply can\'t be a function',
    CONN_CLOSED = 'Connection closed',
    BAD_JSON_MSG = 'Message should be a JSON object',
    BAD_AUTHENTICATION = 'User and Token can not both be provided',

    // Pedantic Mode support
    //Q_SUB = /^([^\.\*>\s]+|>$|\*)(\.([^\.\*>\s]+|>$|\*))*$/, // TODO: remove / never used
    //Q_SUB_NO_WC = /^([^\.\*>\s]+)(\.([^\.\*>\s]+))*$/, // TODO: remove / never used

    FLUSH_THRESHOLD = 65536;

/**
 * Library Version
 */

exports.version = VERSION;

/**
 * Create a properly formatted inbox subject.
 *
 * @api public
*/

var createInbox = exports.createInbox = function() {
  return ("_INBOX." + nuid.next());
};

/**
 * Initialize a client with the appropriate options.
 *
 * @param {Mixed} opts
 * @api public
 */

function Client(opts) {
  events.EventEmitter.call(this);
  this.parseOptions(opts);
  this.initState();
  this.createConnection();
}

/**
 * Connect to a nats-server and return the client.
 * Argument can be a url, or an object with a 'url'
 * property and additional options.
 *
 * @params {Mixed} opts
 *
 * @api public
 */

exports.connect = function(opts) {
  return new Client(opts);
};

/**
 * Connected clients are event emitters.
 */

util.inherits(Client, events.EventEmitter);

/**
 * Allow createInbox to be called on a client.
 *
 * @api public
 */

Client.prototype.createInbox = createInbox;

Client.prototype.assignOption = function(opts, prop, assign) {
  if (assign === undefined) {
    assign = prop;
  }
  if (opts[prop] !== undefined) {
    this.options[assign] = opts[prop];
  }
};

function shuffle(array) {
  for (var i = array.length - 1; i > 0; i--) {
    var j = Math.floor(Math.random() * (i + 1));
    var temp = array[i];
    array[i] = array[j];
    array[j] = temp;
  }
  return array;
}

/**
 * Parse the conctructor/connect options.
 *
 * @param {Mixed} opts
 * @api private
 */

Client.prototype.parseOptions = function(opts) {
  var options = this.options = {
    'verbose'              : false,
    'pedantic'             : false,
    'reconnect'            : true,
    'maxReconnectAttempts' : DEFAULT_MAX_RECONNECT_ATTEMPTS,
    'reconnectTimeWait'    : DEFAULT_RECONNECT_TIME_WAIT,
    'encoding'             : 'utf8',
    'tls'                  : false,
    'waitOnFirstConnect'   : false,
  };

  if (undefined === opts) {
    options.url = DEFAULT_URI;
  } else if ('number' === typeof opts) {
    options.url = DEFAULT_PRE + opts;
  } else if ('string' === typeof opts) {
    options.url = opts;
  } else if ('object' === typeof opts) {
    if (opts.port !== undefined) {
      options.url = DEFAULT_PRE + opts.port;
    }
    // Pull out various options here
    this.assignOption(opts, 'url');
    this.assignOption(opts, 'uri', 'url');
    this.assignOption(opts, 'user');
    this.assignOption(opts, 'pass');
    this.assignOption(opts, 'token');
    this.assignOption(opts, 'password', 'pass');
    this.assignOption(opts, 'verbose');
    this.assignOption(opts, 'pedantic');
    this.assignOption(opts, 'reconnect');
    this.assignOption(opts, 'maxReconnectAttempts');
    this.assignOption(opts, 'reconnectTimeWait');
    this.assignOption(opts, 'servers');
    this.assignOption(opts, 'urls', 'servers');
    this.assignOption(opts, 'noRandomize');
    this.assignOption(opts, 'NoRandomize', 'noRandomize');
    this.assignOption(opts, 'dontRandomize', 'noRandomize');
    this.assignOption(opts, 'encoding');
    this.assignOption(opts, 'tls');
    this.assignOption(opts, 'secure', 'tls');
    this.assignOption(opts, 'name');
    this.assignOption(opts, 'client', 'name');
    this.assignOption(opts, 'yieldTime');
    this.assignOption(opts, 'waitOnFirstConnect');
    this.assignOption(opts, 'json');
  }

  var client = this;

  // Set user/pass as needed if in options.
  client.user = options.user;
  client.pass = options.pass;
  
  // Set token as needed if in options.
  client.token = options.token;

  // Authentication - make sure authentication is valid.
  if (client.user && client.token) {
    throw(new Error(BAD_AUTHENTICATION));
  }

  // Encoding - make sure its valid.
  if (Buffer.isEncoding(options.encoding)) {
    client.encoding = options.encoding;
  } else {
    throw new Error('Invalid Encoding:' + options.encoding);
  }
  // For cluster support
  client.servers = [];

  if (Array.isArray(options.servers)) {
    options.servers.forEach(function(server) {
      client.servers.push(new Server(url.parse(server)));
    });
  } else {
    if (undefined === options.url) {
      options.url = DEFAULT_URI;
    }
    client.servers.push(new Server(url.parse(options.url)));
  }

  // Randomize if needed
  if (options.noRandomize !==  true) {
    shuffle(client.servers);
  }
};

/**
 * Create a new server.
 *
 * @api private
*/

function Server(url) {
  this.url = url;
  this.didConnect = false;
  this.reconnects = 0;
}

/**
 * Properly select the next server.
 * We rotate the server list as we go,
 * we also pull auth from urls as needed, or
 * if they were set in options use that as override.
 *
 * @api private
*/

Client.prototype.selectServer = function() {
  var client = this;
  var server = client.servers.shift();

  // Place in client context.
  client.currentServer = server;
  client.url = server.url;
  if ('auth' in server.url && !!server.url.auth) {
    var auth = server.url.auth.split(':');
    if (auth.length !== 1) {
      if (client.options.user === undefined) {
        client.user = auth[0];
      }
      if (client.options.pass === undefined) {
        client.pass = auth[1];
      }
    } else {
      if (client.options.token === undefined) {
        client.token = auth[0];
      }
    }
  }
  client.servers.push(server);
};

/**
 * Check for TLS configuration mismatch.
 *
 * @api private
*/

Client.prototype.checkTLSMismatch = function() {
  if (this.info.tls_required === true &&
      this.options.tls === false) {
    this.emit('error', 'Server requires a secure connection.');
    this.closeStream();
    return true;
  }

  if (this.info.tls_required === false &&
      this.options.tls !== false) {
    this.emit('error', 'Server does not support a secure connection.');
    this.closeStream();
    return true;
  }

  if (this.info.tls_verify === true &&
      this.options.tls.cert === undefined) {
    this.emit('error', 'Server requires a client certificate.');
    this.closeStream();
    return true;
  }
  return false;
};

/**
 * Callback for first flush/connect.
 *
 * @api private
*/

Client.prototype.connectCB = function() {
  var wasReconnecting = this.reconnecting;
  var event = (wasReconnecting === true) ? 'reconnect' : 'connect';
  this.reconnecting = false;
  this.reconnects = 0;
  this.wasConnected = true;
  this.currentServer.didConnect = true;

  this.emit(event, this);

  this.flushPending();
};


/**
 * Properly setup a stream event handlers.
 *
 * @api private
*/

Client.prototype.setupHandlers = function() {
  var client = this;
  var stream = client.stream;

  if (undefined === stream) {
    return;
  }

  stream.on('connect', function() {
    client.connected = true;
  });

  stream.on('close', function(hadError) {
    client.closeStream();
    client.emit('disconnect');
    if (client.closed === true ||
        client.options.reconnect === false ||
        ((client.reconnects >= client.options.maxReconnectAttempts) && client.options.maxReconnectAttempts !== -1)) {
      client.emit('close');
    } else {
      client.scheduleReconnect();
    }
  });

  stream.on('error', function(exception) {
    // If we were connected just return, close event will process
    if (client.wasConnected === true && client.currentServer.didConnect === true) {
      return;
    }

    // if the current server did not connect at all, and we in
    // general have not connected to any server, remove it from
    // this list. Unless overidden
    if (client.wasConnected === false && client.currentServer.didConnect === false) {
      // We can override this behavior with waitOnFirstConnect, which will
      // treat it like a reconnect scenario.
      if (client.options.waitOnFirstConnect) {
	// Pretend to move us into a reconnect state.
	client.currentServer.didConnect	= true;
      } else {
	client.servers.splice(client.servers.length-1, 1);
      }
    }

    // Only bubble up error if we never had connected
    // to the server and we only have one.
    if (client.wasConnected === false && client.servers.length === 0) {
      client.emit('error', 'Could not connect to server: ' + exception);
    }
    client.closeStream();
  });

  stream.on('data', function (data) {
    // If inbound exists, concat them together. We try to avoid this for split
    // messages, so this should only really happen for a split control line.
    // Long term answer is hand rolled parser and not regexp.
    if (client.inbound) {
      client.inbound = Buffer.concat([client.inbound, data]);
    } else {
      client.inbound = data;
    }

    // Process the inbound queue.
    client.processInbound();
  });
};

/**
 * Send the connect command. This needs to happen after receiving the first
 * INFO message and after TLS is established if necessary.
 *
 * @api private
*/

Client.prototype.sendConnect = function() {
  // Queue the connect command.
  var cs = {
    'lang'    : 'node',
    'version' : VERSION,
    'verbose' : this.options.verbose,
    'pedantic': this.options.pedantic
  };
  if (this.user !== undefined) {
    cs.user = this.user;
    cs.pass = this.pass;
  }
  if (this.token !== undefined) {
    cs.auth_token = this.token;
  }
  if (this.options.name !== undefined) {
    cs.name = this.options.name;
  }

  // If we enqueued requests before we received INFO from the server, or we
  // reconnected, there be other data pending, write this immediately instead
  // of adding it to the queue.
  this.stream.write(CONNECT + SPC + JSON.stringify(cs) + CR_LF);
};

/**
 * Properly setup a stream connection with proper events.
 *
 * @api private
*/

Client.prototype.createConnection = function() {
  // Commands may have been queued during reconnect. Discard everything except:
  // 1) ping requests with a pong callback
  // 2) publish requests
  //
  // Rationale: CONNECT and SUBs are written directly upon connecting, any PONG
  // response is no longer relevant, and any UNSUB will be accounted for when we
  // sync our SUBs. Without this, users of the client may miss state transitions
  // via callbacks, would have to track the client's internal connection state,
  // and may have to double buffer messages (which we are already doing) if they
  // wanted to ensure their messages reach the server.
  var pong = [];
  var pend = [];
  var pSize = 0;
  var client = this;
  if (client.pending !== null) {
    var pongIndex = 0;
    client.pending.forEach(function(cmd) {
      var cmdLen = Buffer.isBuffer(cmd) ? cmd.length : Buffer.byteLength(cmd);
      if (cmd === PING_REQUEST && client.pongs !== null && pongIndex < client.pongs.length) {
        // filter out any useless ping requests (no pong callback, nop flush)
        var p = client.pongs[pongIndex++];
        if (p !== undefined) {
          pend.push(cmd);
          pSize += cmdLen;
          pong.push(p);
        }
      } else if (cmd.length > 3 && cmd[0] == 'P' && cmd[1] == 'U' && cmd[2] == 'B') {
        pend.push(cmd);
        pSize += cmdLen;
      }
    });
  }
  this.pongs   = pong;
  this.pending = pend;
  this.pSize   = pSize;

  this.pstate  = AWAITING_CONTROL;

  // Clear info processing.
  this.info         = null;
  this.infoReceived = false;

  // Select a server to connect to.
  this.selectServer();
  // Create the stream.
  this.stream = net.createConnection(this.url);
  // Setup the proper handlers.
  this.setupHandlers();
};

/**
 * Initialize client state.
 *
 * @api private
 */

Client.prototype.initState = function() {
  this.ssid         = 1;
  this.subs         = {};
  this.reconnects   = 0;
  this.connected    = false;
  this.wasConnected = false;
  this.reconnecting = false;
  this.server       = null;
  this.pending      = [];
};

/**
 * Close the connection to the server.
 *
 * @api public
 */

Client.prototype.close = function() {
  this.closed = true;
  this.removeAllListeners();
  this.closeStream();
  this.ssid     = -1;
  this.subs     = null;
  this.pstate   = -1;
  this.pongs    = null;
  this.pending  = null;
  this.pSize    = 0;
};

/**
 * Close down the stream and clear state.
 *
 * @api private
 */

Client.prototype.closeStream = function() {
  if (this.stream !== null) {
    this.stream.end();
    this.stream.destroy();
    this.stream  = null;
  }
  if (this.connected === true || this.closed === true) {
    this.pongs     = null;
    this.pending   = null;
    this.pSize     = 0;
    this.connected = false;
  }
  this.inbound = null;
};

/**
 * Flush all pending data to the server.
 *
 * @api private
 */

Client.prototype.flushPending = function() {
  if (this.connected === false ||
      this.pending === null ||
      this.pending.length === 0 ||
      this.infoReceived !== true) {
    return;
  }

  var client = this;
  var write = function(data) {
    client.pending = [];
    client.pSize = 0;
    return client.stream.write(data);
  };
  if (!this.pBufs) {
    // All strings, fastest for now.
    return write(this.pending.join(EMPTY));
  } else {
    // We have some or all Buffers. Figure out if we can optimize.
    var allBufs = true;
    for (var i=0; i < this.pending.length; i++){
      if (!Buffer.isBuffer(this.pending[i])) {
	allBufs = false;
	break;
      }
    }
    // If all buffers, concat together and write once.
    if (allBufs) {
      return write(Buffer.concat(this.pending, this.pSize));
    } else {
      // We have a mix, so write each one individually.
      var pending = this.pending;
      this.pending = [];
      this.pSize = 0;
      var result = true;
      for (i=0; i < pending.length; i++){
	      result = this.stream.write(pending[i]) && result;
      }
      return result;
    }
  }
};

/**
 * Strips all SUBS commands from pending during initial connection completed since
 * we send the subscriptions as a separate operation.
 *
 * @api private
 */

Client.prototype.stripPendingSubs = function() {
  var pending = this.pending;
  this.pending = [];
  this.pSize = 0;
  for (var i=0; i < pending.length; i++){
    if (!SUBRE.test(pending[i])) {
      // Re-queue the command.
      this.sendCommand(pending[i]);
    }
  }
};

/**
 * Send commands to the server or queue them up if connection pending.
 *
 * @api private
 */

Client.prototype.sendCommand = function(cmd) {
  // Buffer to cut down on system calls, increase throughput.
  // When receive gets faster, should make this Buffer based..

  if (this.closed || this.pending === null) { return; }

  this.pending.push(cmd);
  if (!Buffer.isBuffer(cmd)) {
    this.pSize += Buffer.byteLength(cmd);
  } else {
    this.pSize += cmd.length;
    this.pBufs = true;
  }

  if (this.connected === true) {
    // First one let's setup flush..
    if (this.pending.length === 1) {
      var self = this;
      setImmediate(function() {
        self.flushPending();
      });
    } else if (this.pSize > FLUSH_THRESHOLD) {
      // Flush in place when threshold reached..
      this.flushPending();
    }
  }
};

/**
 * Sends existing subscriptions to new server after reconnect.
 *
 * @api private
 */

Client.prototype.sendSubscriptions = function() {
  var protos = "";
  for (var sid in this.subs) {
    if (this.subs.hasOwnProperty(sid)) {
      var sub = this.subs[sid];
      var proto;
      if (sub.qgroup) {
	proto = [SUB, sub.subject, sub.qgroup, sid + CR_LF];
      } else {
	proto = [SUB, sub.subject, sid + CR_LF];
      }
      protos += proto.join(SPC);
    }
  }
  if (protos.length > 0) {
    this.stream.write(protos);
  }
};

/**
 * Process the inbound data queue.
 *
 * @api private
 */

Client.prototype.processInbound = function() {
  var client = this;

  // Hold any regex matches.
  var m;

  // For optional yield
  var start;

  // unpause if needed.
  // FIXME(dlc) client.stream.isPaused() causes 0.10 to fail
  client.stream.resume();

  /* jshint -W083 */

  if (client.options.yieldTime !== undefined) {
    start = Date.now();
  }

  while (!client.closed && client.inbound && client.inbound.length > 0) {
    switch (client.pstate) {

    case AWAITING_CONTROL:
      // Regex only works on strings, so convert once to be more efficient.
      // Long term answer is a hand rolled parser, not regex.
      var buf = client.inbound.toString('binary', 0, MAX_CONTROL_LINE_SIZE);
      if ((m = MSG.exec(buf)) !== null) {
        client.payload = {
          subj : m[1],
          sid : parseInt(m[2], 10),
          reply : m[4],
          size : parseInt(m[5], 10)
        };
	client.payload.psize = client.payload.size + CR_LF_LEN;
        client.pstate = AWAITING_MSG_PAYLOAD;
      } else if ((m = OK.exec(buf)) !== null) {
        // Ignore for now..
      } else if ((m = ERR.exec(buf)) !== null) {
        client.emit('error', m[1]);
      } else if ((m = PONG.exec(buf)) !== null) {
        var cb = client.pongs && client.pongs.shift();
        if (cb) { cb(); } // FIXME: Should we check for exceptions?
      } else if ((m = PING.exec(buf)) !== null) {
        client.sendCommand(PONG_RESPONSE);
      } else if ((m = INFO.exec(buf)) !== null) {
	client.info = JSON.parse(m[1]);
	// Check on TLS mismatch.
	if (client.checkTLSMismatch() === true) {
	  return;
	}
	// Process first INFO
	if (client.infoReceived === false) {
	  // Switch over to TLS as needed.
	  if (client.options.tls !== false &&
	      client.stream.encrypted !== true) {
	    var tlsOpts = {socket: client.stream};
	    if ('object' === typeof client.options.tls) {
	      for (var key in client.options.tls) {
		tlsOpts[key] = client.options.tls[key];
	      }
	    }
	    client.stream = tls.connect(tlsOpts, function() {
	      client.flushPending();
	    });
	    client.setupHandlers();
	  }

	  // Send the connect message and subscriptions immediately
	  client.sendConnect();
	  client.sendSubscriptions();

	  client.pongs.unshift(function() { client.connectCB(); });
	  client.stream.write(PING_REQUEST);

	  // Mark as received
	  client.infoReceived = true;
	  client.stripPendingSubs();
	  client.flushPending();
	}
      } else {
        // FIXME, check line length for something weird.
        // Nothing here yet, return
        return;
      }
      break;

    case AWAITING_MSG_PAYLOAD:

      // If we do not have the complete message, hold onto the chunks
      // and assemble when we have all we need. This optimizes for
      // when we parse a large buffer down to a small number of bytes,
      // then we receive a large chunk. This avoids a big copy with a
      // simple concat above.
      if (client.inbound.length < client.payload.psize) {
	if (undefined === client.payload.chunks) {
	  client.payload.chunks = [];
	}
	client.payload.chunks.push(client.inbound);
	client.payload.psize -= client.inbound.length;
        client.inbound = null;
	return;
      }

      // If we are here we have the complete message.
      // Check to see if we have existing chunks
      if (client.payload.chunks) {
	client.payload.chunks.push(client.inbound.slice(0, client.payload.psize));
	var mbuf = Buffer.concat(client.payload.chunks, client.payload.size+CR_LF_LEN);
	client.payload.msg = mbuf.toString(client.encoding, 0, client.payload.size);
      } else {
	client.payload.msg = client.inbound.toString(client.encoding, 0, client.payload.size);
      }

      // Eat the size of the inbound that represents the message.
      if (client.inbound.length === client.payload.psize) {
        client.inbound = null;
      } else {
        client.inbound = client.inbound.slice(client.payload.psize);
      }

      // process the message
      client.processMsg();

      // Reset
      client.pstate = AWAITING_CONTROL;
      client.payload = null;

      // Check to see if we have an option to yield for other events after yieldTime.
      if (start !== undefined) {
	if ((Date.now() - start) > client.options.yieldTime) {
	  client.stream.pause();
	  setImmediate(client.processInbound.bind(this));
	  return;
	}
      }
      break;
    }

    // This is applicable for a regex match to eat the bytes we used from a control line.
    if (m && !this.closed) {
      // Chop inbound
      var psize = m[0].length;
      if (psize >= client.inbound.length) {
        client.inbound = null;
      } else {
        client.inbound = client.inbound.slice(psize);
      }
    }
    m = null;
  }
};

/**
 * Process a delivered message and deliver to appropriate subscriber.
 *
 * @api private
 */

Client.prototype.processMsg = function() {
  var sub = this.subs[this.payload.sid];
  if (sub !== undefined) {
    sub.received += 1;
    // Check for a timeout, and cancel if received >= expected
    if (sub.timeout) {
      if (sub.received >= sub.expected) {
        clearTimeout(sub.timeout);
        sub.timeout = null;
      }
    }
    // Check for auto-unsubscribe
    if (sub.max !== undefined) {
      if (sub.received === sub.max) {
        delete this.subs[this.payload.sid];
	this.emit('unsubscribe', this.payload.sid, sub.subject);
      } else if (sub.received > sub.max) {
        this.unsubscribe(this.payload.sid);
        sub.callback = null;
      }
    }

    if (sub.callback) {
      var msg = this.payload.msg;
      if (this.options.json) {
        try {
          msg = JSON.parse(new Buffer(this.payload.msg, this.options.encoding).toString());
        } catch (e) {
          msg = e;
        }
      }
      sub.callback(msg, this.payload.reply, this.payload.subj, this.payload.sid);
    }
  }
};

/**
 * Push a new cluster server.
 *
 * @param {String} uri
 * @api public
*/

Client.prototype.addServer = function(uri) {
  this.servers.push(new Server(url.parse(uri)));

  if (this.options.noRandomize !==  true) {
    shuffle(this.servers);
  }
};

/**
 * Flush outbound queue to server and call optional callback when server has processed
 * all data.
 *
 * @param {Function} opt_callback
 * @api public
 */

Client.prototype.flush = function(opt_callback) {
  if (this.closed) {
    if (typeof opt_callback === 'function') {
      opt_callback(new Error(CONN_CLOSED));
      return;
    } else {
      throw(new Error(CONN_CLOSED));
    }
  }
  if (this.pongs) {
    this.pongs.push(opt_callback);
    this.sendCommand(PING_REQUEST);
    this.flushPending();
  }
};

/**
 * Publish a message to the given subject, with optional reply and callback.
 *
 * @param {String} subject
 * @param {String} opt_msg
 * @param {String} opt_reply
 * @param {Function} opt_callback
 * @api public
 */

Client.prototype.publish = function(subject, msg, opt_reply, opt_callback) {
  // They only supplied a callback function.
  if (typeof subject === 'function') {
    opt_callback = subject;
    subject = undefined;
  }
  if (!msg) { msg = EMPTY; }
  if (!subject) {
    if (opt_callback) {
      opt_callback(new Error(BAD_SUBJECT));
    } else {
      throw(new Error(BAD_SUBJECT));
    }
  }
  if (typeof msg === 'function') {
    if (opt_callback || opt_reply) {
      opt_callback(new Error(BAD_MSG));
      return;
    }
    opt_callback = msg;
    msg = EMPTY;
    opt_reply = undefined;
  }
  if (typeof opt_reply === 'function') {
    if (opt_callback) {
      opt_callback(new Error(BAD_REPLY));
      return;
    }
    opt_callback = opt_reply;
    opt_reply = undefined;
  }

  // Hold PUB SUB [REPLY]
  var psub;
  if (opt_reply === undefined) {
    psub = 'PUB ' + subject + SPC;
  } else {
    psub = 'PUB ' + subject + SPC + opt_reply + SPC;
  }

  if ('ArrayBuffer' in window && ArrayBuffer.isView(msg)) {
    msg = Buffer.from(msg);
  }

  // Need to treat sending buffers different.
  if (!Buffer.isBuffer(msg)) {
    var str = msg;
    if (this.options.json) {
      if (typeof msg !== 'object' || Array.isArray(msg)) {
        throw(new Error(BAD_JSON_MSG));
      }
      try {
        str = JSON.stringify(msg);
      } catch (e) {
        throw(new Error(BAD_JSON_MSG));
      }
    }
    this.sendCommand(psub + Buffer.byteLength(str) + CR_LF + str + CR_LF);
  } else {
    var b = new Buffer(psub.length + msg.length + (2 * CR_LF_LEN) + msg.length.toString().length);
    var len = b.write(psub + msg.length + CR_LF);
    msg.copy(b, len);
    b.write(CR_LF, len + msg.length);
    this.sendCommand(b);
  }

  if (opt_callback !== undefined) {
    this.flush(opt_callback);
  } else if (this.closed) {
    throw(new Error(CONN_CLOSED));
  }
};

/**
 * Subscribe to a given subject, with optional options and callback. opts can be
 * ommitted, even with a callback. The Subscriber Id is returned.
 *
 * @param {String} subject
 * @param {Object} opts
 * @param {Function} callback
 * @return {Mixed}
 * @api public
 */

Client.prototype.subscribe = function(subject, opts, callback) {
  if (this.closed) {
    throw(new Error(CONN_CLOSED));
  }
  var qgroup, max;
  if (typeof opts === 'function') {
    callback = opts;
    opts = undefined;
  } else if (opts && typeof opts === 'object') {
    // FIXME, check exists, error otherwise..
    qgroup = opts.queue;
    max = opts.max;
  }
  this.ssid += 1;
  this.subs[this.ssid] = { 'subject':subject, 'callback':callback, 'received':0 };

  var proto;
  if (typeof qgroup === 'string') {
    this.subs[this.ssid].qgroup = qgroup;
    proto = [SUB, subject, qgroup, this.ssid + CR_LF];
  } else {
    proto = [SUB, subject, this.ssid + CR_LF];
  }

  this.sendCommand(proto.join(SPC));
  this.emit('subscribe', this.ssid, subject, opts);

  if (max) {
    this.unsubscribe(this.ssid, max);
  }
  return this.ssid;
};

/**
 * Unsubscribe to a given Subscriber Id, with optional max parameter.
 *
 * @param {Mixed} sid
 * @param {Number} opt_max
 * @api public
 */

Client.prototype.unsubscribe = function(sid, opt_max) {
  if (!sid || this.closed) { return; }

  var proto;
  if (opt_max) {
    proto = [UNSUB, sid, opt_max + CR_LF];
  } else {
    proto = [UNSUB, sid + CR_LF];
  }
  this.sendCommand(proto.join(SPC));

  var sub = this.subs[sid];
  if (sub === undefined) {
    return;
  }
  sub.max = opt_max;
  if (sub.max === undefined || (sub.received >= sub.max)) {
    delete this.subs[sid];
    this.emit('unsubscribe', sid, sub.subject);
  }
};

/**
 * Set a timeout on a subscription.
 *
 * @param {Mixed} sid
 * @param {Number} timeout
 * @param {Number} expected
 * @api public
 */

Client.prototype.timeout = function(sid, timeout, expected, callback) {
  if (!sid) { return; }
  var sub = this.subs[sid];
  if (sub === null) { return; }
  sub.expected = expected;
  sub.timeout = setTimeout(function() { callback(sid); }, timeout);
};

/**
 * Publish a message with an implicit inbox listener as the reply. Message is optional.
 * This should be treated as a subscription. You can optionally indicate how many
 * messages you only want to receive using opt_options = {max:N}. Otherwise you
 * will need to unsubscribe to stop the message stream.
 * The Subscriber Id is returned.
 *
 * @param {String} subject
 * @param {String} opt_msg
 * @param {Object} opt_options
 * @param {Function} callback
 * @return {Mixed}
 * @api public
 */

Client.prototype.request = function(subject, opt_msg, opt_options, callback) {
  if (typeof opt_msg === 'function') {
    callback = opt_msg;
    opt_msg = EMPTY;
    opt_options = null;
  }
  if (typeof opt_options === 'function') {
    callback = opt_options;
    opt_options = null;
  }
  var inbox = createInbox();
  var s = this.subscribe(inbox, opt_options, function(msg, reply) {
    callback(msg, reply);
  });
  this.publish(subject, opt_msg, inbox);
  return s;
};

/**
 * Report number of outstanding subscriptions on this connection.
 *
 * @return {Number}
 * @api public
 */

Client.prototype.numSubscriptions = function() {
  return Object.keys(this.subs).length;
};

/**
 * Reconnect to the server.
 *
 * @api private
 */

Client.prototype.reconnect = function() {
  if (this.closed) { return; }
  this.reconnects += 1;
  this.createConnection();
  if (this.currentServer.didConnect === true) {
    this.emit('reconnecting');
  }
};

/**
 * Setup a timer event to attempt reconnect.
 *
 * @api private
 */

Client.prototype.scheduleReconnect = function() {
  var client = this;
  // Just return if no more servers
  if (client.servers.length === 0) {
    return;
  }
  // Don't set reconnecting state if we are just trying
  // for the first time.
  if (client.wasConnected === true) {
    client.reconnecting = true;
  }
  // Only stall if we have connected before.
  var wait = 0;
  if (client.servers[0].didConnect === true) {
    wait = this.options.reconnectTimeWait;
  }
  setTimeout(function() { client.reconnect(); }, wait);
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ "../node_modules/buffer/index.js").Buffer, __webpack_require__(/*! ./../../timers-browserify/main.js */ "../node_modules/timers-browserify/main.js").setImmediate))

/***/ }),

/***/ "../node_modules/websocket-nats/lib/net.js":
/*!*************************************************!*\
  !*** ../node_modules/websocket-nats/lib/net.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var util = __webpack_require__(/*! util */ "../node_modules/util/util.js");
var EventEmitter = __webpack_require__(/*! events */ "../node_modules/events/events.js").EventEmitter;

function WebSocketProxy(url) {
	var self = this;
	EventEmitter.call(this);
	this.sock = new WebSocket(url);
	this.sock.addEventListener('open', function(e) {
		self.emit('connect');
	});
	this.sock.addEventListener('message', function(e) {
		self.emit('data', new Buffer(e.data));
	});
	this.sock.addEventListener('error', function(e) {
		self.emit('error', e);
	});
	this.sock.addEventListener('close', function(e) {
		self.emit('close');
	});
}
util.inherits(WebSocketProxy, EventEmitter);

WebSocketProxy.prototype.end = function() {
	this.destroy();
}

WebSocketProxy.prototype.destroy = function() {
	if (
		this.sock.readyState === WebSocket.CONNECTING ||
		this.sock.readyState === WebSocket.OPEN
	) {
		this.sock.close();
	}
}

WebSocketProxy.prototype.write = function(data) {
	if (this.sock.readyState === WebSocket.OPEN) {
		this.sock.send(data);
	}
}

WebSocketProxy.prototype.pause = function() {
	console.warn('WebSocketProxy stream pause/resume is not supported yet.');
}

WebSocketProxy.prototype.resume = function() {}

exports.createConnection = function(url) {
	// The url is rebuilt to avoid including the auth credentials.
	return new WebSocketProxy(url.format({
		protocol:  url.protocol,
		slashes:   url.slashes,
		host:      url.host,
		hostname:  url.hostname,
		port:      url.port,
		pathname:  url.pathname,
		search:    url.search,
		path:      url.path,
		query:     url.query,
		hash:      url.hash
	}));
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ "../node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "../node_modules/websocket-nats/lib/tls.js":
/*!*************************************************!*\
  !*** ../node_modules/websocket-nats/lib/tls.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.connect = function(opts, cb) {
	throw "TLS is not supported in the browser. Use WSS instead.";
}


/***/ })

}]);
//# sourceMappingURL=vendors~.._node_modules_u.js.map?_rev=ab00953d30adcddaebfd